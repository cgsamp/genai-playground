
>>> ./frontend/.eslintrc.js
module.exports = {
    root: true,
    extends: [
        'next/core-web-vitals',
        'eslint:recommended',
        'plugin:@typescript-eslint/recommended',
        'plugin:react/recommended',
        'plugin:react-hooks/recommended',
        'plugin:jsx-a11y/recommended',
        'prettier',
    ],
    parser: '@typescript-eslint/parser',
    parserOptions: {
        ecmaFeatures: {
            jsx: true,
        },
        ecmaVersion: 2021,
        sourceType: 'module',
    },
    plugins: ['@typescript-eslint', 'react', 'react-hooks', 'jsx-a11y', 'import'],
    rules: {
        'react/react-in-jsx-scope': 'off',
        'react/prop-types': 'off',
        'react-hooks/rules-of-hooks': 'error',
        'react-hooks/exhaustive-deps': 'warn',
        '@typescript-eslint/explicit-module-boundary-types': 'off',
        '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
        'import/order': [
            'error',
            {
                groups: ['builtin', 'external', 'internal', 'parent', 'sibling', 'index'],
                'newlines-between': 'always',
                alphabetize: { order: 'asc', caseInsensitive: true },
            },
        ],
    },
    settings: {
        react: {
            version: 'detect',
        },
    },
};

-----------

>>> ./frontend/next.config.js
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
    reactStrictMode: true,
    swcMinify: true,
}

module.exports = nextConfig

-----------

>>> ./frontend/postcss.config.js
// postcss.config.js
module.exports = {
    plugins: {
        tailwindcss: {},
        autoprefixer: {},
    },
}

-----------

>>> ./frontend/tailwind.config.js
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: [
        './app/**/*.{js,ts,jsx,tsx,mdx}',
        './pages/**/*.{js,ts,jsx,tsx,mdx}',
        './components/**/*.{js,ts,jsx,tsx,mdx}',
    ],
    theme: {
        extend: {},
    },
    plugins: [],
}

-----------

>>> ./frontend/app/config/index.ts
// app/config/index.ts
export const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080';

-----------

>>> ./frontend/app/hooks/useApiError.ts
// hooks/useApiError.ts
'use client';

import { useState } from 'react';
import axios from 'axios';
import { ApiError } from '@/app/types';

export function useApiError() {
    const [error, setError] = useState<ApiError | null>(null);

    const handleApiError = (err: unknown) => {
        if (axios.isAxiosError(err) && err.response) {
            setError({
                status: err.response.status,
                message: err.response.data?.message || err.message,
                details: err.response.data?.details,
            });
        } else if (err instanceof Error) {
            setError({
                status: 500,
                message: err.message,
            });
        } else {
            setError({
                status: 500,
                message: 'An unknown error occurred',
            });
        }
    };

    const clearError = () => setError(null);

    return { error, handleApiError, clearError };
}

-----------

>>> ./frontend/app/hooks/useBooks.ts
// hooks/useBooks.ts
'use client';

import { useState, useEffect } from 'react';
import { Book } from '@/app/types';
import { api } from '@/app/lib/api';
import { useApiError } from './useApiError';

export function useBooks() {
    const [books, setBooks] = useState<Book[]>([]);
    const [loading, setLoading] = useState(true);
    const { error, handleApiError, clearError } = useApiError();

    const fetchBooks = async () => {
        clearError();
        setLoading(true);
        try {
            const data = await api.books.getBooks();
            setBooks(data);
        } catch (err) {
            handleApiError(err);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchBooks();
    }, []);

    return {
        books,
        loading,
        error,
        refreshBooks: fetchBooks
    };
}

-----------

>>> ./frontend/app/hooks/useCollections.ts
// frontend/app/hooks/useCollections.ts
'use client';

import { useState, useEffect } from 'react';
import { CollectionDefinition, CollectionEntity, getCollectionDefinitions, getCollectionEntities } from '@/app/lib/api/collections';
import { useApiError } from './useApiError';

export function useCollections() {
    const [collections, setCollections] = useState<CollectionDefinition[]>([]);
    const [selectedCollection, setSelectedCollection] = useState<CollectionDefinition | null>(null);
    const [entities, setEntities] = useState<CollectionEntity[]>([]);
    const [loading, setLoading] = useState(true);
    const [entitiesLoading, setEntitiesLoading] = useState(false);
    const { error, handleApiError, clearError } = useApiError();

    const fetchCollections = async () => {
        clearError();
        setLoading(true);
        try {
            const data = await getCollectionDefinitions();
            setCollections(data);
        } catch (err) {
            handleApiError(err);
        } finally {
            setLoading(false);
        }
    };

    const fetchEntities = async (collectionId: number) => {
        clearError();
        setEntitiesLoading(true);
        try {
            const data = await getCollectionEntities(collectionId);
            setEntities(data);
        } catch (err) {
            handleApiError(err);
        } finally {
            setEntitiesLoading(false);
        }
    };

    const selectCollection = (collection: CollectionDefinition) => {
        setSelectedCollection(collection);
        void fetchEntities(collection.id);
    };

    useEffect(() => {
        void fetchCollections();
    }, []);

    return {
        collections,
        selectedCollection,
        entities,
        loading,
        entitiesLoading,
        error,
        selectCollection,
        refreshCollections: fetchCollections
    };
}

-----------

>>> ./frontend/app/hooks/useItems.ts
'use client';

import { useState, useEffect } from 'react';
import { Item } from '@/app/types';
import * as itemsApi from '@/app/lib/api/items';
import { useApiError } from './useApiError';

export function useItems(itemType?: string) {
    const [items, setItems] = useState<Item[]>([]);
    const [loading, setLoading] = useState(true);
    const { error, handleApiError, clearError } = useApiError();

    const fetchItems = async () => {
        clearError();
        setLoading(true);
        try {
            const data = await itemsApi.getItems(itemType);
            setItems(data);
        } catch (err) {
            handleApiError(err);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        void fetchItems();
    }, [itemType]);

    const createItem = async (item: Omit<Item, 'id' | 'createdAt' | 'updatedAt'>) => {
        try {
            const newItem = await itemsApi.createItem(item);
            setItems(prev => [...prev, newItem]);
            return newItem;
        } catch (err) {
            handleApiError(err);
            throw err;
        }
    };

    const updateItem = async (id: number, updates: Partial<Item>) => {
        try {
            const updatedItem = await itemsApi.updateItem(id, updates);
            setItems(prev => prev.map(item =>
                item.id === id ? updatedItem : item
            ));
            return updatedItem;
        } catch (err) {
            handleApiError(err);
            throw err;
        }
    };

    const deleteItem = async (id: number) => {
        try {
            await itemsApi.deleteItem(id);
            setItems(prev => prev.filter(item => item.id !== id));
        } catch (err) {
            handleApiError(err);
            throw err;
        }
    };

    return {
        items,
        loading,
        error,
        refreshItems: fetchItems,
        createItem,
        updateItem,
        deleteItem
    };
}

-----------

>>> ./frontend/app/lib/api/books.ts
import axios from 'axios';
import { Book, EntitySummary } from '@/app/types';
import { API_URL } from '@/app/config';

export const getBooks = async (): Promise<Book[]> => {
    const response = await axios.get<Book[]>(`${API_URL}/api/books`);
    return response.data;
};

export const getBookSummaries = async (bookIds: number[]): Promise<EntitySummary[]> => {
    const response = await axios.get<EntitySummary[]>(
        `${API_URL}/api/summaries?entity=ranked_book&entityIds=${bookIds.join(',')}`
    );
    return response.data;
};

-----------

>>> ./frontend/app/lib/api/chat.ts
import axios from 'axios';
import { ChatRequest, ChatResponse } from '@/app/types';
import { API_URL } from '@/app/config';

export const sendChatMessage = async (content: string): Promise<ChatResponse> => {
    const request: ChatRequest = { content };
    const response = await axios.post<ChatResponse>(`${API_URL}/chat`, request);
    return response.data;
};

-----------

>>> ./frontend/app/lib/api/collections.ts
// frontend/app/lib/api/collections.ts
import axios from 'axios';
import { Item } from './items';
import { API_URL } from '@/app/config';

export interface CollectionDefinition {
    id: number;
    name: string;
    description?: string;
    curator?: string;
}

export interface CollectionEntity {
    id: number;
    itemId: number;
    itemName: string;
    position?: number;
    addedDate?: string;
    // Item details loaded from the unified Item model
    details?: Item;
}

export interface CollectionWithEntities {
    definition: CollectionDefinition;
    entities: CollectionEntity[];
}

export interface Relationship {
    id: number;
    name: string;
    relationshipType: string;
    sourceItemId: number;
    targetItemId: number;
    attributes?: Record<string, any>;
    createdAt: string;
    updatedAt: string;
}

export const getCollectionDefinitions = async (): Promise<CollectionDefinition[]> => {
    const response = await axios.get<Relationship[]>(
        `${API_URL}/api/relationships/type/collection_definition`
    );

    return response.data.map(rel => ({
        id: rel.targetItemId, // Collection ID is the target in the relationship
        name: rel.name,
        description: rel.attributes?.description as string,
        curator: rel.attributes?.curator as string,
    }));
};

export const getCollectionEntities = async (collectionId: number): Promise<CollectionEntity[]> => {
    // Get all relationships where target is the collection
    const response = await axios.get<Relationship[]>(
        `${API_URL}/api/relationships/collection/${collectionId}`
    );

    // Filter for collection member relationships (not collection_definition)
    const collectionRels = response.data.filter(rel =>
        rel.relationshipType === 'collection' &&
        rel.targetItemId === collectionId
    );

    // Transform to CollectionEntity format
    const entities: CollectionEntity[] = collectionRels.map(rel => ({
        id: rel.id,
        itemId: rel.sourceItemId,
        itemName: rel.name,
        position: rel.attributes?.position as number,
        addedDate: rel.attributes?.added_date as string,
    }));

    // Now fetch the actual item details for each entity
    const entitiesWithDetails = await Promise.all(
        entities.map(async (entity) => {
            try {
                const itemResponse = await axios.get<Item>(`${API_URL}/api/items/${entity.itemId}`);
                const item = itemResponse.data;

                return {
                    ...entity,
                    itemName: item.name || entity.itemName,
                    details: item
                };
            } catch (error) {
                console.warn(`Failed to fetch details for item ${entity.itemId}:`, error);
                return entity;
            }
        })
    );

    // Sort by position if available
    return entitiesWithDetails.sort((a, b) => {
        if (a.position && b.position) {
            return a.position - b.position;
        }
        return a.itemName.localeCompare(b.itemName);
    });
};

export const getCollectionWithEntities = async (collectionId: number): Promise<CollectionWithEntities> => {
    const [definition, entities] = await Promise.all([
        getCollectionDefinitions().then(defs => defs.find(d => d.id === collectionId)),
        getCollectionEntities(collectionId)
    ]);

    if (!definition) {
        throw new Error(`Collection with ID ${collectionId} not found`);
    }

    return {
        definition,
        entities
    };
};

export const createCollection = async (
    name: string,
    description?: string,
    curator?: string
): Promise<CollectionDefinition> => {
    // First create the collection as an item
    const collectionItem = await axios.post<Item>(`${API_URL}/api/items`, {
        itemType: 'collection',
        name,
        description,
        attributes: {
            curator,
            itemCount: 0
        }
    });

    // Then create the collection_definition relationship
    const relationshipData = {
        name,
        relationshipType: 'collection_definition',
        sourceItemId: collectionItem.data.id,
        targetItemId: collectionItem.data.id,
        attributes: {
            description,
            curator
        }
    };

    await axios.post(`${API_URL}/api/relationships`, relationshipData);

    return {
        id: collectionItem.data.id,
        name,
        description,
        curator
    };
};

export const addItemToCollection = async (
    collectionId: number,
    itemId: number,
    position?: number
): Promise<void> => {
    const relationshipData = {
        name: `Item ${itemId} in Collection ${collectionId}`,
        relationshipType: 'collection',
        sourceItemId: itemId,
        targetItemId: collectionId,
        attributes: {
            position,
            added_date: new Date().toISOString()
        }
    };

    await axios.post(`${API_URL}/api/relationships`, relationshipData);
};

export const removeItemFromCollection = async (
    collectionId: number,
    itemId: number
): Promise<void> => {
    // Find the relationship to delete
    const relationships = await axios.get<Relationship[]>(
        `${API_URL}/api/relationships/collection/${collectionId}`
    );

    const relationshipToDelete = relationships.data.find(rel =>
        rel.relationshipType === 'collection' &&
        rel.sourceItemId === itemId &&
        rel.targetItemId === collectionId
    );

    if (relationshipToDelete) {
        await axios.delete(`${API_URL}/api/relationships/${relationshipToDelete.id}`);
    }
};

-----------

>>> ./frontend/app/lib/api/configs.ts
// app/lib/api/configs.ts
import axios from 'axios';
import { ModelConfiguration } from '@/app/types';
import { API_URL } from '@/app/config';

export const getConfigurations = async (): Promise<ModelConfiguration[]> => {
    const response = await axios.get<ModelConfiguration[]>(`${API_URL}/api/model-configurations`);
    return response.data;
};

export const getConfiguration = async (id: number): Promise<ModelConfiguration> => {
    const response = await axios.get<ModelConfiguration>(`${API_URL}/api/model-configurations/${id}`);
    return response.data;
};

export const createConfiguration = async (config: Omit<ModelConfiguration, 'id' | 'createdAt'>): Promise<ModelConfiguration> => {
    const response = await axios.post<ModelConfiguration>(`${API_URL}/api/model-configurations`, config);
    return response.data;
};

-----------

>>> ./frontend/app/lib/api/cytoscape.ts
// app/lib/api/cytoscape.ts
import axios from 'axios';
import { API_URL } from '@/app/config';

export const getCytoscapeData = async (): Promise<any> => {
    const response = await axios.get(`${API_URL}/api/cytoscape/books-summaries`);
    return response.data;
};

-----------

>>> ./frontend/app/lib/api/index.ts
import * as itemsApi from './items';
import * as chatApi from './chat';
import * as modelsApi from './models';
import * as configsApi from './configs';
import * as cytoscapeApi from './cytoscape';
import * as collectionsApi from './collections';
import * as operationsApi from './operations';

export const api = {
    items: itemsApi,
    chat: chatApi,
    models: modelsApi,
    configs: configsApi,
    cytoscape: cytoscapeApi,
    collections: collectionsApi,
    operations: operationsApi,
};

-----------

>>> ./frontend/app/lib/api/items.ts
// frontend/app/lib/api/items.ts
import axios from 'axios';
import { API_URL } from '@/app/config';

export interface Item {
    id: number;
    itemType: string;
    name: string;
    description?: string;
    creator?: string;
    createdYear?: string;
    externalId?: string;
    source?: string;
    attributes: Record<string, any>;
    createdAt: string;
    updatedAt: string;
}

export interface ItemSummary {
    id: number;
    itemId: number;
    itemName: string;
    itemDetails?: string;
    content: string;
    modelName: string;
    modelProvider: string;
    modelId: number;
    modelConfigurationId: number;
    modelConfig: Record<string, any>;
    configComment: string;
    createdAt: string;
}

export const getItems = async (itemType?: string): Promise<Item[]> => {
    const url = itemType
        ? `${API_URL}/api/items?itemType=${itemType}`
        : `${API_URL}/api/items`;
    const response = await axios.get<Item[]>(url);
    return response.data;
};

export const getItem = async (id: number): Promise<Item> => {
    const response = await axios.get<Item>(`${API_URL}/api/items/${id}`);
    return response.data;
};

export const createItem = async (item: Omit<Item, 'id' | 'createdAt' | 'updatedAt'>): Promise<Item> => {
    const response = await axios.post<Item>(`${API_URL}/api/items`, item);
    return response.data;
};

export const updateItem = async (id: number, item: Partial<Item>): Promise<Item> => {
    const response = await axios.put<Item>(`${API_URL}/api/items/${id}`, item);
    return response.data;
};

export const deleteItem = async (id: number): Promise<void> => {
    await axios.delete(`${API_URL}/api/items/${id}`);
};

export const searchItems = async (itemType?: string, searchTerm?: string): Promise<Item[]> => {
    const params = new URLSearchParams();
    if (itemType) params.append('itemType', itemType);
    if (searchTerm) params.append('searchTerm', searchTerm);

    const response = await axios.get<Item[]>(`${API_URL}/api/items/search?${params}`);
    return response.data;
};

export const getItemSummaries = async (itemIds: number[]): Promise<ItemSummary[]> => {
    const response = await axios.get<ItemSummary[]>(
        `${API_URL}/api/summaries/items?itemIds=${itemIds.join(',')}`
    );
    return response.data;
};

export const getItemTypes = async (): Promise<string[]> => {
    const response = await axios.get<string[]>(`${API_URL}/api/items/types`);
    return response.data;
};

-----------

>>> ./frontend/app/lib/api/models.ts
// app/lib/api/models.ts
import axios from 'axios';
import { Model, ModelConfiguration, ModelParameter, ModelCallRequest, ModelCallResponse } from '@/app/types';
import { API_URL } from '@/app/config';

export const getModels = async (): Promise<Model[]> => {
    const response = await axios.get<Model[]>(`${API_URL}/api/models`);
    return response.data;
};

export const createModel = async (modelData: Omit<Model, 'id'>): Promise<Model> => {
    const response = await axios.post<Model>(`${API_URL}/api/models`, modelData);
    return response.data;
};

export const getModelConfigurations = async (): Promise<ModelConfiguration[]> => {
    const response = await axios.get<ModelConfiguration[]>(`${API_URL}/api/model-configurations`);
    return response.data;
};

export const createModelConfiguration = async (configData: Omit<ModelConfiguration, 'id' | 'createdAt'>): Promise<ModelConfiguration> => {
    const response = await axios.post<ModelConfiguration>(`${API_URL}/api/model-configurations`, configData);
    return response.data;
};

export const getModelParameters = async (modelId: number): Promise<ModelParameter[]> => {
    const response = await axios.get<ModelParameter[]>(`${API_URL}/api/model-parameters/model/${modelId}`);
    return response.data;
};

export const invokeModel = async (modelConfigId: number, prompt: string): Promise<ModelCallResponse> => {
    const request: ModelCallRequest = {
        modelConfigurationId: modelConfigId,
        prompt
    };
    const response = await axios.post<ModelCallResponse>(`${API_URL}/api/batch-summary`, request);
    return response.data;
};

-----------

>>> ./frontend/app/lib/api/operations.ts
// frontend/app/lib/api/operations.ts

import axios from 'axios';
import { API_URL } from '@/app/config';
import type {
    OperationRequest,
    OperationResponse,
    SummarizeEachResult,
    SummarizeGroupResult,
    GenerateRelationshipsResult
} from '@/app/types/operations';

export const executeOperation = async (request: OperationRequest): Promise<OperationResponse> => {
    const response = await axios.post<OperationResponse>(`${API_URL}/api/operations/execute`, request);
    return response.data;
};

// Specific operation functions for type safety
export const summarizeEach = async (
    modelConfigurationId: number,
    collectionId: number
): Promise<SummarizeEachResult> => {
    const request: OperationRequest = {
        operationId: 'summarize_each',
        modelConfigurationId,
        collectionId,
    };

    const response = await executeOperation(request);
    if (response.status === 'error') {
        throw new Error(response.message);
    }

    // Extract the specific properties we need
    return {
        successCount: response.results?.successCount || 0,
        failureCount: response.results?.failureCount || 0,
        summaryIds: response.results?.summaryIds || []
    };
};

export const summarizeGroup = async (
    modelConfigurationId: number,
    collectionId: number
): Promise<SummarizeGroupResult> => {
    const request: OperationRequest = {
        operationId: 'summarize_group',
        modelConfigurationId,
        collectionId,
    };

    const response = await executeOperation(request);
    if (response.status === 'error') {
        throw new Error(response.message);
    }

    // Extract the specific properties we need
    return {
        summaryId: response.results?.summaryId || 0,
        collectionId: response.results?.collectionId || collectionId,
        entityCount: response.results?.entityCount || 0
    };
};

export const generateRelationships = async (
    modelConfigurationId: number,
    collectionId: number,
    relationshipTypes?: string[]
): Promise<GenerateRelationshipsResult> => {
    const request: OperationRequest = {
        operationId: 'generate_relationships',
        modelConfigurationId,
        collectionId,
        parameters: {
            relationshipTypes: relationshipTypes || ['similar_themes', 'influenced_by', 'contrasts_with']
        }
    };

    const response = await executeOperation(request);
    if (response.status === 'error') {
        throw new Error(response.message);
    }

    // Extract the specific properties we need
    return {
        relationshipCount: response.results?.relationshipCount || 0,
        relationshipIds: response.results?.relationshipIds || [],
        summaryIds: response.results?.summaryIds || [],
        entityPairsProcessed: response.results?.entityPairsProcessed || 0
    };
};

-----------

>>> ./frontend/app/lib/fetcher.ts
// lib/fetcher.ts

const BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL!;

export async function fetcher<T>(path: string, options?: RequestInit): Promise<T> {
    const res = await fetch(`${BASE_URL}${path}`, {
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...(options?.headers || {}),
        },
    });

    if (!res.ok) {
        const errorBody = await res.text();
        throw new Error(`Fetch error ${res.status}: ${errorBody}`);
    }

    return res.json();
}

-----------

>>> ./frontend/app/lib/operations/registry.ts
import { FileText, Users, Link2 } from 'lucide-react';
import type { Operation } from '@/app/types/operations';

export const OPERATIONS: Record<string, Operation> = {
    SUMMARIZE_EACH: {
        id: 'summarize_each',
        name: 'Summarize Each',
        description: 'Generate individual summaries for each entity in the collection',
        requiresCollection: true,
    },
    SUMMARIZE_GROUP: {
        id: 'summarize_group',
        name: 'Summarize Group',
        description: 'Generate a single summary for the entire collection',
        requiresCollection: true,
    },
    GENERATE_RELATIONSHIPS: {
        id: 'generate_relationships',
        name: 'Generate Relationships',
        description: 'Analyze relationships between entities in the collection',
        requiresCollection: true,
    },
};

export const getAvailableOperations = (hasCollection: boolean): Operation[] => {
    return Object.values(OPERATIONS).filter(op =>
        !op.requiresCollection || hasCollection
    );
};

export const getOperationById = (id: string): Operation | undefined => {
    return Object.values(OPERATIONS).find(op => op.id === id);
};

-----------

>>> ./frontend/app/types/api.ts
export interface ApiOptions {
    baseUrl?: string;
    headers?: Record<string, string>;
}

-----------

>>> ./frontend/app/types/book.ts
import { ID } from './common';
import { Attributes } from './common';

export interface BookRankSource {
    id: ID;
    orgName: string;
    publishDate: string;
}

export interface Book {
    id: ID;
    rank: number;
    title: string;
    authorName: string;
    publishYear: string;
    source?: BookRankSource;
    attributes: Attributes;
}

export interface BookSummaryRequest {
    modelConfigurationId: ID;
    prompt: string;
}

export interface BookSummaryResponse {
    successCount: number;
    failureCount: number;
}

-----------

>>> ./frontend/app/types/chat.ts
export type ChatRole = 'user' | 'bot' | 'error' | 'system';

export interface ChatMessage {
    role: ChatRole;
    content: string;
    timestamp?: string;
}

export interface ChatRequest {
    content: string;
}

export interface ChatResponse {
    reply: string;
}

-----------

>>> ./frontend/app/types/common.ts
export type ID = number;

export interface ApiResponse<T> {
    data: T;
    status: number;
    message?: string;
}

export type ApiError = {
    status: number;
    message: string;
    details?: Record<string, string[]>;
};

export type Attributes = Record<string, unknown>;

export interface SelectedEntity {
    id: number;
    type: 'book' | 'person' | 'summary' | 'relationship';
    name: string;
}

-----------

>>> ./frontend/app/types/index.ts
export * from './api';
export * from './book';
export * from './chat';
export * from './common';
export * from './model';
export * from './item';

-----------

>>> ./frontend/app/types/item.ts
import { ID, Attributes } from './common';

export interface Item {
    id: ID;
    itemType: string;
    name: string;
    description?: string;
    creator?: string;
    createdYear?: string;
    externalId?: string;
    source?: string;
    attributes: Attributes;
    createdAt: string;
    updatedAt: string;
}

export interface CreateItemRequest {
    itemType: string;
    name: string;
    description?: string;
    creator?: string;
    createdYear?: string;
    externalId?: string;
    source?: string;
    attributes?: Attributes;
}

export interface ItemSearchParams {
    itemType?: string;
    searchTerm?: string;
    creator?: string;
    createdYear?: string;
    source?: string;
}

export interface ItemSummary {
    id: ID;
    itemId: ID;
    itemName: string;
    itemDetails?: string;
    content: string;
    modelName: string;
    modelProvider: string;
    modelId: ID;
    modelConfigurationId: ID;
    modelConfig: Record<string, any>;
    configComment: string;
    createdAt: string;
}

export interface SelectedItem {
    id: number;
    itemType: string;
    name: string;
}

-----------

>>> ./frontend/app/types/model.ts
import { ID } from './common';

export interface Model {
    id: ID;
    modelName: string;
    modelProvider: string;
    modelApiUrl: string;
    comment: string;
}

export interface ModelParameter {
    id: ID;
    modelId: ID;
    paramName: string;
    description: string;
    dataType: string;
    minValue: string;
    maxValue: string;
    defaultValue: string;
    displayOrder: number;
}

export interface ModelConfiguration {
    id: ID;
    modelId: ID;
    modelName?: string;
    modelProvider?: string;
    modelConfig: Record<string, any>;
    comment: string;
    createdAt: string;
}

export interface ModelCallRequest {
    modelConfigurationId: ID;
    prompt: string;
}

export interface ModelCallResponse {
    response: string;
}

export interface EntitySummary {
    id: ID;
    entityId: ID;
    summary: string;
    modelName: string;
    modelProvider: string;
    modelId: ID;
    modelConfigurationId: ID;
    modelConfig: Record<string, any>;
    configComment: string;
    createdAt: string;
}

-----------

>>> ./frontend/app/types/operations.ts
// frontend/app/types/operations.ts

export interface Operation {
    id: string;
    name: string;
    description: string;
    requiresCollection: boolean;
    icon?: React.ComponentType<{ size?: number; className?: string }>;
}

export interface OperationRequest {
    operationId: string;
    modelConfigurationId: number;
    collectionId?: number;
    parameters?: Record<string, any>;
}

export interface OperationResponse {
    operationId: string;
    status: 'success' | 'error' | 'partial';
    message: string;
    results?: {
        // Common properties that all operations might have
        successCount?: number;
        failureCount?: number;
        createdEntities?: number[];
        details?: any;

        // Specific to SummarizeEach
        summaryIds?: number[];

        // Specific to SummarizeGroup
        summaryId?: number;
        collectionId?: number;
        entityCount?: number;

        // Specific to GenerateRelationships
        relationshipCount?: number;
        relationshipIds?: number[];
        entityPairsProcessed?: number;
    };
}

// Specific operation result types - these should match what the backend actually returns
export interface SummarizeEachResult {
    successCount: number;
    failureCount: number;
    summaryIds: number[];
}

export interface SummarizeGroupResult {
    summaryId: number;
    collectionId: number;
    entityCount: number;
}

export interface GenerateRelationshipsResult {
    relationshipCount: number;
    relationshipIds: number[];
    summaryIds: number[];
    entityPairsProcessed: number;
}

-----------

>>> ./frontend/app/types/person.ts
import {Attributes, ID} from "@/app/types/common";

export interface Person {
    id: ID;
    name: string;
    email: string;
    occupation: string;
    birthdate: string;
    attributes: Attributes;
}

-----------

>>> ./frontend/app/types/relationship.ts
import {Attributes} from "@/app/types/common";
import type {DetailedSummary} from "@/app/types/summary";

export interface Relationship {
    id: number;
    name: string;
    relationshipType : string;
    sourceType: string;
    sourceId: number;
    targetType: string;
    targetId :number;
    createdAt: string;
    updatedAt: string;
    attributes: Attributes;
}

export interface RelatedItems {
    relationships: Relationship[];
    summaries: DetailedSummary[];
}

-----------

>>> ./frontend/app/types/summary.ts
import {Attributes} from "@/app/types/common";

export interface Summary {
    id: number;
    entityId: number;
    entityType: string;
    content: string;
    createdAt: string;
    attributes: Attributes;
}

export interface DetailedSummary {
    id: number;
    entityId: number;
    entityType: string;
    entityName?: string;
    entityDetails?: string;
    content: string;
    modelName: string;
    modelProvider: string;
    modelId: number;
    modelConfigurationId: number;
    modelConfig: any;
    configComment: string;
    createdAt: string;
    attributes: Attributes;
}

-----------

>>> ./frontend/next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

-----------

>>> ./.run/Backend.run.xml
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="Backend" type="MavenRunConfiguration" factoryName="Maven">
    <MavenSettings>
      <option name="myGeneralSettings" />
      <option name="myRunnerSettings" />
      <option name="myRunnerParameters">
        <MavenRunnerParameters>
          <option name="cmdOptions" />
          <option name="profiles">
            <set />
          </option>
          <option name="goals">
            <list>
              <option value="clean" />
              <option value="spring-boot:run" />
              <option value="-DskipTests" />
            </list>
          </option>
          <option name="multimoduleDir" />
          <option name="pomFileName" />
          <option name="profilesMap">
            <map />
          </option>
          <option name="projectsCmdOptionValues">
            <list />
          </option>
          <option name="resolveToWorkspace" value="false" />
          <option name="workingDirPath" value="$PROJECT_DIR$/backend" />
        </MavenRunnerParameters>
      </option>
    </MavenSettings>
    <extension name="net.ashald.envfile">
      <option name="IS_ENABLED" value="true" />
      <option name="IS_SUBST" value="false" />
      <option name="IS_PATH_MACRO_SUPPORTED" value="false" />
      <option name="IS_IGNORE_MISSING_FILES" value="false" />
      <option name="IS_ENABLE_EXPERIMENTAL_INTEGRATIONS" value="false" />
      <ENTRIES>
        <ENTRY IS_ENABLED="true" PARSER="runconfig" IS_EXECUTABLE="false" />
        <ENTRY IS_ENABLED="true" PARSER="env" IS_EXECUTABLE="false" PATH=".env" />
      </ENTRIES>
    </extension>
    <method v="2" />
  </configuration>
</component>
-----------

>>> ./.run/dev.run.xml
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="dev" type="js.build_tools.npm" nameIsGenerated="true">
    <package-json value="$PROJECT_DIR$/frontend/package.json" />
    <command value="run" />
    <scripts>
      <script value="dev" />
    </scripts>
    <node-interpreter value="project" />
    <envs />
    <method v="2" />
  </configuration>
</component>
-----------

>>> ./backend/pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- Corrected backend/pom.xml for Spring AI 1.0.0 GA -->
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.4.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>net.sampsoftware</groupId>
    <artifactId>Backend</artifactId>
    <version>0.1.0-SNAPSHOT</version>
    <name>genai</name>
    <description>GenAI Playground</description>
    <url/>
    <licenses>
        <license/>
    </licenses>
    <developers>
        <developer/>
    </developers>
    <scm>
        <connection/>
        <developerConnection/>
        <tag/>
        <url/>
    </scm>
    <properties>
        <java.version>21</java.version>
        <spring-ai.version>1.0.0</spring-ai.version>
        <mapstruct.version>1.5.5.Final</mapstruct.version>
        <lombok.version>1.18.30</lombok.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-starter-model-openai</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>

        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>1.5.5.Final</version>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-processor</artifactId>
            <version>1.5.5.Final</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.32</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok-mapstruct-binding</artifactId>
            <version>0.2.0</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.hibernate.orm</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>6.4.4.Final</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.junit.platform</groupId>
            <artifactId>junit-platform-launcher</artifactId>
            <version>1.10.1</version>
            <scope>test</scope>
        </dependency>

        <!-- Testcontainers -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.ai</groupId>
                <artifactId>spring-ai-bom</artifactId>
                <version>${spring-ai.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.testcontainers</groupId>
                <artifactId>testcontainers-bom</artifactId>
                <version>1.19.1</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.1.2</version>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.10.1</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                    <compilerArgs>
                        <compilerArg>-Amapstruct.defaultComponentModel=spring</compilerArg>
                        <compilerArg>-Amapstruct.verbose=true</compilerArg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

-----------

>>> ./backend/run.sh
#!/bin/bash
set -eo pipefail
IFS=$'\n\t'

set -a
source ../.env
set +a

set -x

./mvnw clean package -DskipTests
./mvnw $1 $2 $3 $4

-----------

>>> ./copy_books_tab.sh
#!/bin/bash

# Set variables
NEW_PANEL_NAME="Books2Panel"
NEW_ROUTE_NAME="books2"
NEW_DISPLAY_LABEL="Books 2"

echo "Creating new panel ${NEW_PANEL_NAME} for Next.js project"

# Check if the original Books component exists
BOOKS_DIR="./frontend/app/components/books"
if [ ! -d "$BOOKS_DIR" ]; then
  echo "Creating books component directory"
  mkdir -p "$BOOKS_DIR"
fi

if [ ! -f "${BOOKS_DIR}/BooksPanel.tsx" ] && [ ! -f "${BOOKS_DIR}/BooksPanel.jsx" ]; then
  echo "Error: Books component not found in expected locations"
  exit 1
fi

# Determine file extension (.tsx or .jsx)
if [ -f "${BOOKS_DIR}/BooksPanel.tsx" ]; then
  EXT="tsx"
else
  EXT="jsx"
fi

# Create new panel component as a copy of BooksPanel
cp "${BOOKS_DIR}/BooksPanel.${EXT}" "${BOOKS_DIR}/${NEW_PANEL_NAME}.${EXT}"
echo "Created component file: ${BOOKS_DIR}/${NEW_PANEL_NAME}.${EXT}"

# Update component name in the new file
sed -i "s/BooksPanel/${NEW_PANEL_NAME}/g" "${BOOKS_DIR}/${NEW_PANEL_NAME}.${EXT}"
echo "Updated component name references"

# Create or update page route directory
mkdir -p "./frontend/app/${NEW_ROUTE_NAME}"

# Create layout.tsx for the new route
cat > "./frontend/app/${NEW_ROUTE_NAME}/layout.tsx" << EOF
export default function ${NEW_PANEL_NAME}Layout({
  children,
}: {
  children: React.ReactNode
}) {
  return children;
}
EOF
echo "Created layout file at ./frontend/app/${NEW_ROUTE_NAME}/layout.tsx"

# Create page.tsx with proper imports
cat > "./frontend/app/${NEW_ROUTE_NAME}/page.tsx" << EOF
import ${NEW_PANEL_NAME} from '../../components/books/${NEW_PANEL_NAME}';
import { Metadata } from 'next';

export const metadata: Metadata = {
  title: '${NEW_DISPLAY_LABEL}',
  description: '${NEW_DISPLAY_LABEL} panel',
};

export default function ${NEW_ROUTE_NAME}Page() {
  return <${NEW_PANEL_NAME} />;
}
EOF
echo "Created route page at ./frontend/app/${NEW_ROUTE_NAME}/page.tsx"

# Find and update Navigation.tsx
NAVIGATION_FILE="./frontend/app/components/ui/Navigation.tsx"
if [ -f "$NAVIGATION_FILE" ]; then
  # Check if the books entry exists to place our new entry after it
  if grep -q "path: '/books'" "$NAVIGATION_FILE"; then
    # Use awk to insert the new navigation item after the books entry
    awk '/path: .\/books./ { print; print "  { path: '"'"'\/'"$NEW_ROUTE_NAME"''"'"', label: '"'"''"$NEW_DISPLAY_LABEL"''"'"', icon: <Book size={18} \/> },"; next }1' "$NAVIGATION_FILE" > temp.txt
    mv temp.txt "$NAVIGATION_FILE"
    echo "Added navigation item to $NAVIGATION_FILE"
  else
    echo "Warning: Could not find '/books' path in Navigation.tsx. You may need to add it manually."
  fi
else
  echo "Warning: Navigation.tsx not found at expected location. You may need to update navigation manually."
fi

echo "Done! The new panel is accessible at /${NEW_ROUTE_NAME}"

-----------

>>> ./docker/postgres/init/02-create_database.sh
#!/bin/bash

set -e

APP_DATABASE=${APP_DATABASE:-playground}
POSTGRES_APP_USER=${POSTGRES_APP_USER:-genai}
POSTGRES_APP_PASSWORD=${POSTGRES_APP_PASSWORD:-genai}

SCRIPT_DIR="$(dirname "$0")"
SUBSCRIPTS_DIR="${SCRIPT_DIR}/subscripts"

echo "Checking for database '$APP_DATABASE'..."

# Check if database exists - using standard variable interpolation
db_exists=$(psql -U "$POSTGRES_USER" -d "postgres" -t -c "SELECT 1 FROM pg_database WHERE datname = '$APP_DATABASE';")
db_exists=$(echo "$db_exists" | tr -d ' ')

# Check if the variable has content
if [ -n "$db_exists" ]; then
  echo "Database '$APP_DATABASE' already exists."
else
  echo "Creating database '$APP_DATABASE'..."
  psql -U "$POSTGRES_USER" -d "postgres" -c "CREATE DATABASE \"$APP_DATABASE\";"

  # Check if user already exists before creating
  user_exists=$(psql -U "$POSTGRES_USER" -d "postgres" -t -c "SELECT 1 FROM pg_roles WHERE rolname = '$POSTGRES_APP_USER';")
  user_exists=$(echo "$user_exists" | tr -d ' ')

  if [ -n "$user_exists" ]; then
    echo "User '$POSTGRES_APP_USER' already exists."
  else
    echo "Creating user '$POSTGRES_APP_USER'..."
    psql -U "$POSTGRES_USER" -d "postgres" -c "CREATE USER \"$POSTGRES_APP_USER\" WITH PASSWORD '$POSTGRES_APP_PASSWORD';"
  fi

  echo "Creating schema..."
  psql -U "$POSTGRES_USER" -d "$APP_DATABASE" -f "${SUBSCRIPTS_DIR}/schema.sql"

  echo "Granting privileges to '$POSTGRES_APP_USER'..."
  psql -U "$POSTGRES_USER" -d "postgres" -c "GRANT ALL PRIVILEGES ON DATABASE \"$APP_DATABASE\" TO \"$POSTGRES_APP_USER\";"

  psql -U "$POSTGRES_USER" -d "$APP_DATABASE" -c "
    GRANT ALL PRIVILEGES ON SCHEMA public TO \"$POSTGRES_APP_USER\";
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL PRIVILEGES ON TABLES TO \"$POSTGRES_APP_USER\";
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL PRIVILEGES ON SEQUENCES TO \"$POSTGRES_APP_USER\";
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL PRIVILEGES ON FUNCTIONS TO \"$POSTGRES_APP_USER\";
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO \"$POSTGRES_APP_USER\";
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO \"$POSTGRES_APP_USER\";
    GRANT ALL PRIVILEGES ON ALL FUNCTIONS IN SCHEMA public TO \"$POSTGRES_APP_USER\";
  "
  echo "Database initialization complete!"
fi

-----------

>>> ./docker/postgres/init/03-load_data.sh
#!/bin/bash

set -e

APP_DATABASE=${APP_DATABASE:-playground}

SCRIPT_DIR="$(dirname "$0")"
SUBSCRIPTS_DIR="${SCRIPT_DIR}/subscripts"

echo "Loading data if table empty..."
load_table_data() {
  local table_name="$1"
  local count=$(psql -U "$POSTGRES_USER" -d "$APP_DATABASE" -t -c "SELECT COUNT(*) FROM $table_name;")
  count=$(echo "$count" | tr -d ' ')

  if [ "$count" -gt "0" ]; then
    echo "$table_name already loaded."
  else
    echo "Loading $table_name..."
    psql -U "$POSTGRES_USER" -d "$APP_DATABASE" -f "${SUBSCRIPTS_DIR}/${table_name}.sql"
    echo "$table_name loaded."
  fi
}

load_table_data model
load_table_data model_parameter
load_table_data model_configuration
load_table_data book_rank_source
load_table_data ranked_books

echo "Loading entity test data"
   psql -U "$POSTGRES_USER" -d "$APP_DATABASE" -f "${SUBSCRIPTS_DIR}/entity_test_data.sql"

echo "Done!"

-----------

>>> ./backend/src/main/resources/application.yml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        model: gpt-3.5-turbo
        options:
          temperature: 0.7
          max-tokens: 1000

  application:
    name: genai

  datasource:
    url: jdbc:postgresql://localhost:5432/${APP_DATABASE}
    username: ${POSTGRES_APP_USERNAME}
    password: ${POSTGRES_APP_PASSWORD}
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false

  sql:
    init:
      mode: always
      schema-location: classpath:/schema.sql
logging:
  level:
    '[org.springframework.ai]': INFO
    '[org.springframework.boot.autoconfigure]': INFO
    '[org.springframework.web]': INFO
    '[org.springframework.web.filter.CommonsRequestLoggingFilter]': DEBUG
    '[net.sampsoftware.genai]': DEBUG
    '[net.sampsoftware.genai.controller]': TRACE

server:
  port: 8080

springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html
    operations-sorter: method

-----------

>>> ./backend/src/test/resources/application.yml
spring:
  ai:
    openai:
      api-key: testkey
      chat:
        options:
          model: gpt-3.5-turbo

  datasource:
    url: jdbc:tc:postgresql:15:///testdb
    driver-class-name: org.testcontainers.jdbc.ContainerDatabaseDriver
    username: test
    password: test

  jpa:
    hibernate:
      ddl-auto: update
    database-platform: org.hibernate.dialect.PostgreSQLDialect

-----------

>>> ./docker/docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:16
    container_name: genai-postgres
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${POSTGRES_ADMIN_PASSWORD:-postgres}
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./postgres/init:/docker-entrypoint-initdb.d
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USERNAME:-postgres} -d playground"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - genai-network

volumes:
  postgres-data:
    name: genai-postgres-data

networks:
  genai-network:
    name: genai-network
    driver: bridge

-----------

>>> ./frontend/package.json
{
  "name": "genai-dashboard-next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "node ./node_modules/next/dist/bin/next dev",
    "build": "node ./node_modules/next/dist/bin/next build",
    "start": "node ./node_modules/next/dist/bin/next start",
    "lint": "node ./node_modules/next/dist/bin/next lint",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "axios": "^1.6.2",
    "cytoscape": "^3.28.1",
    "lucide-react": "^0.294.0",
    "next": "^15.3.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/cytoscape": "^3.19.14",
    "@types/node": "^20.10.4",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.17",
    "autoprefixer": "^10.4.16",
    "eslint": "^9.27.0",
    "eslint-config-next": "15.3.1",
    "glob": "^10.3.10",
    "lru-cache": "^10.1.0",
    "postcss": "^8.4.32",
    "rimraf": "^5.0.5",
    "tailwindcss": "^3.3.6",
    "typescript": "^5.3.3"
  },
  "overrides": {
    "glob": "^10.3.10",
    "rimraf": "^5.0.5",
    "inflight": "npm:lru-cache@^10.1.0"
  }
}

-----------

>>> ./frontend/tsconfig.json
{
  "compilerOptions": {
    "target": "es6",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

-----------

>>> ./package.json
{
  "dependencies": {
    "@tailwindcss/forms": "^0.5.10",
    "axios": "^1.9.0",
    "install": "^0.13.0",
    "lucide-react": "^0.511.0",
    "npm": "^11.4.0",
    "react-router-dom": "^7.6.0",
    "tailwindcss": "^4.1.7"
  }
}

-----------

>>> ./docker/postgres/init/archive/book_rank_source.sql
INSERT INTO book_rank_source (org_name, publish_date) VALUES ('New York Times','2024-07-08') RETURNING id;

-----------

>>> ./docker/postgres/init/archive/model_configuration.sql
-- SQL script with properly escaped apostrophes

-- First, ensure we have the models
INSERT INTO model (model_name, model_provider, model_api_url, comment) 
SELECT 'gpt-3.5-turbo', 'OpenAI', 'https://api.openai.com/v1', 'GPT-3.5 Turbo model'
WHERE NOT EXISTS (SELECT 1 FROM model WHERE model_name = 'gpt-3.5-turbo');

INSERT INTO model (model_name, model_provider, model_api_url, comment) 
SELECT 'gpt-4', 'OpenAI', 'https://api.openai.com/v1', 'GPT-4 model'
WHERE NOT EXISTS (SELECT 1 FROM model WHERE model_name = 'gpt-4');

-- Get model IDs for insertion
DO $$
DECLARE
    gpt35_id bigint;
    gpt4_id bigint;
BEGIN
    SELECT id INTO gpt35_id FROM model WHERE model_name = 'gpt-3.5-turbo';
    SELECT id INTO gpt4_id FROM model WHERE model_name = 'gpt-4';
    
    -- Common parameters for GPT-3.5 Turbo
    -- Temperature
    INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
    SELECT gpt35_id, 'temperature', 
           'Controls randomness in token selection. Lower values make output more deterministic and focused (0 is deterministic), higher values make output more random and creative.', 
           'number', '0.0', '2.0', '0.7', 1
    WHERE NOT EXISTS (SELECT 1 FROM model_parameter WHERE model_id = gpt35_id AND param_name = 'temperature');

    -- Top_p
    INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
    SELECT gpt35_id, 'top_p', 
           'Controls diversity via nucleus sampling. The model considers tokens with top_p probability mass. 0.1 means only the tokens comprising the top 10% probability are considered.', 
           'number', '0.0', '1.0', '1.0', 2
    WHERE NOT EXISTS (SELECT 1 FROM model_parameter WHERE model_id = gpt35_id AND param_name = 'top_p');

    -- Max_tokens
    INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
    SELECT gpt35_id, 'max_tokens', 
           'Maximum number of tokens to generate. The total length of input tokens and output tokens is limited by the model context length.', 
           'integer', '1', '4096', '1024', 3
    WHERE NOT EXISTS (SELECT 1 FROM model_parameter WHERE model_id = gpt35_id AND param_name = 'max_tokens');

    -- Frequency_penalty
    INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
    SELECT gpt35_id, 'frequency_penalty', 
           'Reduces repetition by penalizing tokens based on how frequently they''ve appeared in the text so far. Higher values decrease repetition.', 
           'number', '-2.0', '2.0', '0.0', 4
    WHERE NOT EXISTS (SELECT 1 FROM model_parameter WHERE model_id = gpt35_id AND param_name = 'frequency_penalty');

    -- Presence_penalty
    INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
    SELECT gpt35_id, 'presence_penalty', 
           'Reduces repetition by penalizing tokens that have appeared at all in the text so far. Higher values increase the model''s likelihood to talk about new topics.', 
           'number', '-2.0', '2.0', '0.0', 5
    WHERE NOT EXISTS (SELECT 1 FROM model_parameter WHERE model_id = gpt35_id AND param_name = 'presence_penalty');

    -- Common parameters for GPT-4
    -- Temperature
    INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
    SELECT gpt4_id, 'temperature', 
           'Controls randomness in token selection. Lower values make output more deterministic and focused (0 is deterministic), higher values make output more random and creative.', 
           'number', '0.0', '2.0', '0.7', 1
    WHERE NOT EXISTS (SELECT 1 FROM model_parameter WHERE model_id = gpt4_id AND param_name = 'temperature');

    -- Top_p
    INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
    SELECT gpt4_id, 'top_p', 
           'Controls diversity via nucleus sampling. The model considers tokens with top_p probability mass. 0.1 means only the tokens comprising the top 10% probability are considered.', 
           'number', '0.0', '1.0', '1.0', 2
    WHERE NOT EXISTS (SELECT 1 FROM model_parameter WHERE model_id = gpt4_id AND param_name = 'top_p');

    -- Max_tokens
    INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
    SELECT gpt4_id, 'max_tokens', 
           'Maximum number of tokens to generate. The total length of input tokens and output tokens is limited by the model context length.', 
           'integer', '1', '8192', '1500', 3
    WHERE NOT EXISTS (SELECT 1 FROM model_parameter WHERE model_id = gpt4_id AND param_name = 'max_tokens');

    -- Frequency_penalty
    INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
    SELECT gpt4_id, 'frequency_penalty', 
           'Reduces repetition by penalizing tokens based on how frequently they''ve appeared in the text so far. Higher values decrease repetition.', 
           'number', '-2.0', '2.0', '0.0', 4
    WHERE NOT EXISTS (SELECT 1 FROM model_parameter WHERE model_id = gpt4_id AND param_name = 'frequency_penalty');

    -- Presence_penalty
    INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
    SELECT gpt4_id, 'presence_penalty', 
           'Reduces repetition by penalizing tokens that have appeared at all in the text so far. Higher values increase the model''s likelihood to talk about new topics.', 
           'number', '-2.0', '2.0', '0.0', 5
    WHERE NOT EXISTS (SELECT 1 FROM model_parameter WHERE model_id = gpt4_id AND param_name = 'presence_penalty');
END $$;
-----------

>>> ./docker/postgres/init/archive/test_data.sql
insert into model (model_name, model_provider, model_api_url, comment) values ('Test model', 'Model Test Inc', 'https://example.com/api','This is here to test things.') returning id;
INSERT INTO model_configuration (model_id, model_config, comment, created_at)
VALUES (
  1,
  '{"temperature": 0.7, "max_tokens": 150, "top_p": 0.9}',
  'Sample config for testing',
  now()
);
insert into entity_summary (model_configuration_id, entity, entity_id, summary, created_at)
values (
1, 'ranked_books',3,'This book was less than wonderful.',now()
);
insert into entity_summary (model_configuration_id, entity, entity_id, summary, created_at)
values (
1, 'ranked_books',3,'I thought it was okay.',now()
);

-----------

>>> ./docker/postgres/init/archive/top100of21st.sql
INSERT INTO book_rank_source (org_name, publish_date) VALUES ('New York Times','2024-07-08') RETURNING id;

INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,1,'My Brilliant Friend','Elena Ferrante',2012);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,2,'The Warmth of Other Suns','Isabel Wilkerson',2010);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,3,'Wolf Hall','Hilary Mantel',2009);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,4,'The Known World','Edward P. Jones',2003);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,5,'The Corrections','Jonathan Franzen',2001);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,6,'2666','Roberto Bolaño',2008);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,7,'The Underground Railroad','Colson Whitehead',2016);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,8,'Austerlitz','W.G. Sebald',2001);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,9,'Never Let Me Go','Kazuo Ishiguro',2005);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,10,'Gilead','Marilynne Robinson',2004);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,11,'The Brief Wondrous Life of Oscar Wao','Junot Díaz',2007);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,12,'The publish_year of Magical Thinking','Joan Didion',2005);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,13,'The Road','Cormac McCarthy',2006);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,14,'Outline','Rachel Cusk',2015);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,15,'Pachinko','Min Jin Lee',2017);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,16,'The Amazing Adventures of Kavalier & Clay','Michael Chabon',2000);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,17,'The Sellout','Paul Beatty',2015);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,18,'Lincoln in the Bardo','George Saunders',2017);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,19,'Say Nothing','Patrick Radden Keefe',2019);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,20,'Erasure','Percival Everett',2001);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,21,'Evicted','Matthew Desmond',2016);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,22,'Behind the Beautiful Forevers','Katherine Boo',2012);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,23,'Hateship, Friendship, Courtship, Loveship, Marriage','Alice Munro',2001);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,24,'The Overstory','Richard Powers',2018);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,25,'Random Family','Adrian Nicole LeBlanc',2003);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,26,'Atonement','Ian McEwan',2002);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,27,'Americanah','Chimamanda Ngozi Adichie',2013);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,28,'Cloud Atlas','David Mitchell',2004);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,29,'The Last Samurai','Helen DeWitt',2000);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,30,'Sing, Unburied, Sing','Jesmyn Ward',2017);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,31,'White Teeth','Zadie Smith',2000);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,32,'The Line of Beauty','Alan Hollinghurst',2004);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,33,'Salvage the Bones','Jesmyn Ward',2011);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,34,'Citizen','Claudia Rankine',2014);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,35,'Fun Home','Alison Bechdel',2006);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,36,'Between the World and Me','Ta-Nehisi Coates',2015);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,37,'The publish_years','Annie Ernaux',2018);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,38,'The Savage Detectives','Roberto Bolaño',2007);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,39,'A Visit From the Goon Squad','Jennifer Egan',2010);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,40,'H Is for Hawk','Helen Macdonald',2015);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,41,'Small Things Like These','Claire Keegan',2021);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,42,'A Brief History of Seven Killings','Marlon James',2014);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,43,'Postwar','Tony Judt',2005);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,44,'The Fifth Season','N. K. Jemisin',2015);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,45,'The Argonauts','Maggie Nelson',2015);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,46,'The Goldfinch','Donna Tartt',2013);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,47,'A Mercy','Toni Morrison',2008);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,48,'Persepolis','Marjane Satrapi',2003);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,49,'The Vegetarian','Han Kang',2016);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,50,'Trust','Hernan Diaz',2022);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,51,'Life After Life','Kate Atkinson',2013);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,52,'Train Dreams','Denis Johnson',2011);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,53,'Runaway','Alice Munro',2004);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,54,'Tenth of December','George Saunders',2013);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,55,'The Looming Tower','Lawrence Wright',2006);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,56,'The Flamethrowers','Rachel Kushner',2013);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,57,'Nickel and Dimed','Barbara Ehrenreich',2001);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,58,'Stay True','Hua Hsu',2022);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,59,'Middlesex','Jeffrey Eugenides',2002);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,60,'Heavy','Kiese Laymon',2018);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,61,'Demon Copperhead','Barbara Kingsolver',2022);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,62,'10:04','Ben Lerner',2014);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,63,'Veronica','Mary Gaitskill',2005);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,64,'The Great Believers','Rebecca Makkai',2018);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,65,'The Plot Against America','Philip Roth',2004);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,66,'We the Animals','Justin Torres',2011);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,67,'Far From the Tree','Andrew Solomon',2012);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,68,'The Friend','Sigrid Nunez',2018);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,69,'The New Jim Crow','Michelle Alexander',2010);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,70,'All Aunt Hagar''s Children','Edward P. Jones',2006);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,71,'The Copenhagen Trilogy','Tove Ditlevsen',2021);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,72,'Secondhand Time','Svetlana Alexievich',2016);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,73,'The Passage of Power','Robert Caro',2012);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,74,'Olive Kitteridge','Elizabeth Strout',2008);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,75,'Exit West','Mohsin Hamid',2017);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,76,'Tomorrow, and Tomorrow, and Tomorrow','Gabrielle Zevin',2022);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,77,'An American Marriage','Tayari Jones',2018);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,78,'Septology','Jon Fosse',2022);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,79,'A Manual for Cleaning Women','Lucia Berlin',2015);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,80,'The Story of the Lost Child','Elena Ferrante',2015);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,81,'Pulphead','John Jeremiah Sullivan',2011);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,82,'Hurricane Season','Fernanda Melchor',2020);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,83,'When We Cease to Understand the World','Benjamín Labatut',2021);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,84,'The Emperor of All Maladies','Siddhartha Mukherjee',2010);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,85,'Pastoralia','George Saunders',2000);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,86,'Frederick Douglass','David W. Blight',2018);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,87,'Detransition, Baby','Torrey Peters',2021);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,88,'The Collected Stories of Lydia Davis','Lydia Davis',2010);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,89,'The Return','Hisham Matar',2016);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,90,'The Sympathizer','Viet Thanh Nguyen',2015);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,91,'The Human Stain','Philip Roth',2000);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,92,'The Days of Abandonment','Elena Ferrante',2005);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,93,'Station Eleven','Emily St. John Mandel',2014);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,94,'On Beauty','Zadie Smith',2005);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,95,'Bring Up the Bodies','Hilary Mantel',2012);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,96,'Wayward Lives, Beautiful Experiments','Saidiya Hartman',2019);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,97,'Men We Reaped','Jesmyn Ward',2013);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,98,'Bel Canto','Ann Patchett',2001);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,99,'How to Be Both','Ali Smith',2014);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,100,'Tree of Smoke','Denis Johnson',2007);

-----------

>>> ./docker/postgres/init/subscripts/book_rank_source.sql
INSERT INTO book_rank_source (id, org_name, publish_date) VALUES (1,'New York Times','2024-07-08') RETURNING id;

-----------

>>> ./docker/postgres/init/subscripts/entity_test_data.sql
-- Initial test data for books table
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM books WHERE name = 'To Kill a Mockingbird') THEN
        INSERT INTO books (name, author_name, publish_year, attributes, created_at, updated_at)
        VALUES ('To Kill a Mockingbird', 'Harper Lee', '1960',
                '{"genre": "Fiction", "tags": ["classic", "southern"], "rank": 1, "pages": 281}',
                NOW(), NOW());
END IF;

    IF NOT EXISTS (SELECT 1 FROM books WHERE name = '1984') THEN
        INSERT INTO books (name, author_name, publish_year, attributes, created_at, updated_at)
        VALUES ('1984', 'George Orwell', '1949',
                '{"genre": "Dystopian", "tags": ["political", "classic"], "rank": 2, "pages": 328}',
                NOW(), NOW());
END IF;

    IF NOT EXISTS (SELECT 1 FROM books WHERE name = 'The Great Gatsby') THEN
        INSERT INTO books (name, author_name, publish_year, attributes, created_at, updated_at)
        VALUES ('The Great Gatsby', 'F. Scott Fitzgerald', '1925',
                '{"genre": "Fiction", "tags": ["classic", "american"], "rank": 3, "pages": 180}',
                NOW(), NOW());
END IF;

    IF NOT EXISTS (SELECT 1 FROM books WHERE name = 'Pride and Prejudice') THEN
        INSERT INTO books (name, author_name, publish_year, attributes, created_at, updated_at)
        VALUES ('Pride and Prejudice', 'Jane Austen', '1813',
                '{"genre": "Romance", "tags": ["classic", "regency"], "rank": 4, "pages": 432}',
                NOW(), NOW());
END IF;
END
$$;

-- Initial test data for people table
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM people WHERE name = 'Harper Lee') THEN
        INSERT INTO people (name, email, birth_date, occupation, attributes, created_at, updated_at)
        VALUES ('Harper Lee', 'harper.lee@example.com', '1926-04-28', 'Author',
                '{"nationality": "American", "awards": ["Pulitzer Prize"], "biography": "Nelle Harper Lee was an American novelist..."}',
                NOW(), NOW());
END IF;

    IF NOT EXISTS (SELECT 1 FROM people WHERE name = 'George Orwell') THEN
        INSERT INTO people (name, email, birth_date, occupation, attributes, created_at, updated_at)
        VALUES ('George Orwell', 'george.orwell@example.com', '1903-06-25', 'Author',
                '{"nationality": "British", "real_name": "Eric Arthur Blair", "biography": "English novelist and essayist..."}',
                NOW(), NOW());
END IF;

    IF NOT EXISTS (SELECT 1 FROM people WHERE name = 'F. Scott Fitzgerald') THEN
        INSERT INTO people (name, email, birth_date, occupation, attributes, created_at, updated_at)
        VALUES ('F. Scott Fitzgerald', 'scott.fitzgerald@example.com', '1896-09-24', 'Author',
                '{"nationality": "American", "biography": "American novelist, essayist, and short story writer..."}',
                NOW(), NOW());
END IF;

    IF NOT EXISTS (SELECT 1 FROM people WHERE name = 'Jane Austen') THEN
        INSERT INTO people (name, email, birth_date, occupation, attributes, created_at, updated_at)
        VALUES ('Jane Austen', 'jane.austen@example.com', '1775-12-16', 'Author',
                '{"nationality": "British", "biography": "English novelist known primarily for her six major novels..."}',
                NOW(), NOW());
END IF;

    IF NOT EXISTS (SELECT 1 FROM people WHERE name = 'John Smith') THEN
        INSERT INTO people (name, email, birth_date, occupation, attributes, created_at, updated_at)
        VALUES ('John Smith', 'john.smith@example.com', '1980-05-15', 'Literary Critic',
                '{"education": "PhD in Literature", "specialization": "20th Century Fiction"}',
                NOW(), NOW());
END IF;
END
$$;

-- Initial test data for summaries table
DO $$
DECLARE
book_id_mockingbird BIGINT;
    book_id_1984 BIGINT;
BEGIN
    -- Get IDs of existing books
SELECT id INTO book_id_mockingbird FROM books WHERE name = 'To Kill a Mockingbird';
SELECT id INTO book_id_1984 FROM books WHERE name = '1984';

IF book_id_mockingbird IS NOT NULL AND NOT EXISTS (SELECT 1 FROM summaries WHERE entity_type = 'book' AND entity_id = book_id_mockingbird) THEN
        INSERT INTO summaries (name, entity_type, entity_id, content, source, attributes, created_at, updated_at)
        VALUES ('Classic Summary of To Kill a Mockingbird', 'book', book_id_mockingbird,
                'Set in the 1930s Alabama, this novel follows Scout Finch and her father Atticus, a lawyer defending a Black man accused of raping a white woman. The story explores themes of racial injustice, moral growth, and the loss of innocence.',
                'ClassicLiteratureGuide',
                '{"quality_score": 4.8, "word_count": 42}',
                NOW(), NOW());
END IF;

    IF book_id_mockingbird IS NOT NULL AND NOT EXISTS (SELECT 1 FROM summaries WHERE entity_type = 'book' AND entity_id = book_id_mockingbird AND source = 'AI-Generated') THEN
        INSERT INTO summaries (name, entity_type, entity_id, content, source, attributes, created_at, updated_at)
        VALUES ('AI Summary of To Kill a Mockingbird', 'book', book_id_mockingbird,
                'Harper Lee''s powerful novel explores racial prejudice and moral complexity through the eyes of a young girl in Depression-era Alabama. The narrative centers around her father''s legal defense of a Black man falsely accused of a crime, revealing deep social divides and the importance of empathy and moral courage.',
                'AI-Generated',
                '{"quality_score": 4.2, "word_count": 51, "model": "GPT-4"}',
                NOW(), NOW());
END IF;

    IF book_id_1984 IS NOT NULL AND NOT EXISTS (SELECT 1 FROM summaries WHERE entity_type = 'book' AND entity_id = book_id_1984) THEN
        INSERT INTO summaries (name, entity_type, entity_id, content, source, attributes, created_at, updated_at)
        VALUES ('Summary of 1984', 'book', book_id_1984,
                'Orwell''s dystopian masterpiece depicts a totalitarian future where Big Brother watches everyone and the Thought Police suppress individualism. The protagonist Winston Smith rebels against the Party by falling in love and keeping a diary, only to face the horrific consequences of challenging the system.',
                'LiteraryArchive',
                '{"quality_score": 4.9, "word_count": 47}',
                NOW(), NOW());
END IF;
END
$$;

-- Initial test data for relationships table
DO $$
DECLARE
book_id_mockingbird BIGINT;
    book_id_1984 BIGINT;
    book_id_gatsby BIGINT;
    book_id_pride BIGINT;
    person_id_lee BIGINT;
    person_id_orwell BIGINT;
    person_id_fitzgerald BIGINT;
    person_id_austen BIGINT;
    person_id_smith BIGINT;
BEGIN
    -- Get IDs of existing entities
SELECT id INTO book_id_mockingbird FROM books WHERE name = 'To Kill a Mockingbird';
SELECT id INTO book_id_1984 FROM books WHERE name = '1984';
SELECT id INTO book_id_gatsby FROM books WHERE name = 'The Great Gatsby';
SELECT id INTO book_id_pride FROM books WHERE name = 'Pride and Prejudice';

SELECT id INTO person_id_lee FROM people WHERE name = 'Harper Lee';
SELECT id INTO person_id_orwell FROM people WHERE name = 'George Orwell';
SELECT id INTO person_id_fitzgerald FROM people WHERE name = 'F. Scott Fitzgerald';
SELECT id INTO person_id_austen FROM people WHERE name = 'Jane Austen';
SELECT id INTO person_id_smith FROM people WHERE name = 'John Smith';

-- Author relationships
IF person_id_lee IS NOT NULL AND book_id_mockingbird IS NOT NULL AND
       NOT EXISTS (SELECT 1 FROM relationships WHERE relationship_type = 'authored' AND source_type = 'person' AND source_id = person_id_lee AND target_type = 'book' AND target_id = book_id_mockingbird) THEN
        INSERT INTO relationships (name, relationship_type, source_type, source_id, target_type, target_id, attributes, created_at, updated_at)
        VALUES ('Harper Lee authored To Kill a Mockingbird', 'authored', 'person', person_id_lee, 'book', book_id_mockingbird,
                '{"year": 1960, "publisher": "J. B. Lippincott & Co."}',
                NOW(), NOW());
END IF;

    IF person_id_orwell IS NOT NULL AND book_id_1984 IS NOT NULL AND
       NOT EXISTS (SELECT 1 FROM relationships WHERE relationship_type = 'authored' AND source_type = 'person' AND source_id = person_id_orwell AND target_type = 'book' AND target_id = book_id_1984) THEN
        INSERT INTO relationships (name, relationship_type, source_type, source_id, target_type, target_id, attributes, created_at, updated_at)
        VALUES ('George Orwell authored 1984', 'authored', 'person', person_id_orwell, 'book', book_id_1984,
                '{"year": 1949, "publisher": "Secker & Warburg"}',
                NOW(), NOW());
END IF;

    IF person_id_fitzgerald IS NOT NULL AND book_id_gatsby IS NOT NULL AND
       NOT EXISTS (SELECT 1 FROM relationships WHERE relationship_type = 'authored' AND source_type = 'person' AND source_id = person_id_fitzgerald AND target_type = 'book' AND target_id = book_id_gatsby) THEN
        INSERT INTO relationships (name, relationship_type, source_type, source_id, target_type, target_id, attributes, created_at, updated_at)
        VALUES ('F. Scott Fitzgerald authored The Great Gatsby', 'authored', 'person', person_id_fitzgerald, 'book', book_id_gatsby,
                '{"year": 1925, "publisher": "Charles Scribner''s Sons"}',
                NOW(), NOW());
END IF;

    IF person_id_austen IS NOT NULL AND book_id_pride IS NOT NULL AND
       NOT EXISTS (SELECT 1 FROM relationships WHERE relationship_type = 'authored' AND source_type = 'person' AND source_id = person_id_austen AND target_type = 'book' AND target_id = book_id_pride) THEN
        INSERT INTO relationships (name, relationship_type, source_type, source_id, target_type, target_id, attributes, created_at, updated_at)
        VALUES ('Jane Austen authored Pride and Prejudice', 'authored', 'person', person_id_austen, 'book', book_id_pride,
                '{"year": 1813, "publisher": "T. Egerton, Whitehall"}',
                NOW(), NOW());
END IF;

    -- Critic relationship
    IF person_id_smith IS NOT NULL AND book_id_mockingbird IS NOT NULL AND
       NOT EXISTS (SELECT 1 FROM relationships WHERE relationship_type = 'reviewed' AND source_type = 'person' AND source_id = person_id_smith AND target_type = 'book' AND target_id = book_id_mockingbird) THEN
        INSERT INTO relationships (name, relationship_type, source_type, source_id, target_type, target_id, attributes, created_at, updated_at)
        VALUES ('John Smith reviewed To Kill a Mockingbird', 'reviewed', 'person', person_id_smith, 'book', book_id_mockingbird,
                '{"date": "2022-05-10", "rating": 5, "publication": "Literary Review Quarterly"}',
                NOW(), NOW());
END IF;

    -- Books similarity relationship
    IF book_id_1984 IS NOT NULL AND book_id_mockingbird IS NOT NULL AND
       NOT EXISTS (SELECT 1 FROM relationships WHERE relationship_type = 'similar_themes' AND source_type = 'book' AND source_id = book_id_1984 AND target_type = 'book' AND target_id = book_id_mockingbird) THEN
        INSERT INTO relationships (name, relationship_type, source_type, source_id, target_type, target_id, attributes, created_at, updated_at)
        VALUES ('1984 and To Kill a Mockingbird share themes', 'similar_themes', 'book', book_id_1984, 'book', book_id_mockingbird,
                '{"themes": ["social justice", "moral courage"], "similarity_score": 0.72}',
                NOW(), NOW());
END IF;

    -- Books series/collection relationship (example of a meta-relationship)
    IF book_id_1984 IS NOT NULL AND book_id_gatsby IS NOT NULL AND book_id_mockingbird IS NOT NULL AND
       NOT EXISTS (SELECT 1 FROM relationships WHERE relationship_type = 'collection' AND source_type = 'book' AND source_id = book_id_1984 AND target_type = 'collection' AND target_id = 1) THEN
        -- Create a virtual "collection" entity first in relationships
        IF NOT EXISTS (SELECT 1 FROM relationships WHERE name = 'Classic Fiction Collection' AND relationship_type = 'collection_definition') THEN
            INSERT INTO relationships (name, relationship_type, source_type, source_id, target_type, target_id, attributes, created_at, updated_at)
            VALUES ('Classic Fiction Collection', 'collection_definition', 'collection', 1, 'collection', 1,
                    '{"description": "Notable classic fiction works", "curator": "Literary Canon Committee"}',
                    NOW(), NOW());
END IF;

        -- Now add books to this collection
INSERT INTO relationships (name, relationship_type, source_type, source_id, target_type, target_id, attributes, created_at, updated_at)
VALUES ('1984 in Classic Fiction Collection', 'collection', 'book', book_id_1984, 'collection', 1,
        '{"added_date": "2023-01-15", "position": 1}',
        NOW(), NOW());

INSERT INTO relationships (name, relationship_type, source_type, source_id, target_type, target_id, attributes, created_at, updated_at)
VALUES ('The Great Gatsby in Classic Fiction Collection', 'collection', 'book', book_id_gatsby, 'collection', 1,
        '{"added_date": "2023-01-15", "position": 2}',
        NOW(), NOW());

INSERT INTO relationships (name, relationship_type, source_type, source_id, target_type, target_id, attributes, created_at, updated_at)
VALUES ('To Kill a Mockingbird in Classic Fiction Collection', 'collection', 'book', book_id_mockingbird, 'collection', 1,
        '{"added_date": "2023-01-15", "position": 3}',
        NOW(), NOW());
END IF;
END
$$;

-----------

>>> ./docker/postgres/init/subscripts/model.sql
INSERT INTO model (model_name, model_provider, model_api_url, comment)
VALUES
    ('GPT-3.5-Turbo', 'OpenAI', 'https://api.openai.com/v1/chat/completions', 'General purpose model, good balance of capabilities and cost'),
    ('GPT-4o', 'OpenAI', 'https://api.openai.com/v1/chat/completions', 'Advanced model with strong reasoning and instruction-following'),
    ('Claude 3 Opus', 'Anthropic', 'https://api.anthropic.com/v1/messages', 'Anthropic''s most capable model for complex tasks'),
    ('Claude 3 Sonnet', 'Anthropic', 'https://api.anthropic.com/v1/messages', 'Balanced performance and cost for most use cases'),
    ('Llama-3-70b', 'Meta', 'https://api.together.xyz/v1/completions', 'Open source model with strong general capabilities');

-----------

>>> ./docker/postgres/init/subscripts/model_configuration.sql

INSERT INTO model_configuration (model_id, model_config, comment, created_at)
VALUES
    (
        (SELECT id FROM model WHERE model_name = 'GPT-3.5-Turbo'),
        '{"temperature": 0.7, "max_tokens": 1024, "top_p": 0.95}',
        'Default configuration for general usage',
        NOW()
    ),
    (
        (SELECT id FROM model WHERE model_name = 'GPT-3.5-Turbo'),
        '{"temperature": 0.2, "max_tokens": 2048, "top_p": 0.9, "frequency_penalty": 0.5}',
        'More deterministic output, good for factual responses',
        NOW()
    ),
    (
        (SELECT id FROM model WHERE model_name = 'GPT-3.5-Turbo'),
        '{"temperature": 1.2, "max_tokens": 500, "top_p": 1.0, "presence_penalty": 0.6}',
        'Creative configuration for brainstorming and idea generation',
        NOW()
    );

-- GPT-4o configurations
INSERT INTO model_configuration (model_id, model_config, comment, created_at)
VALUES
    (
        (SELECT id FROM model WHERE model_name = 'GPT-4o'),
        '{"temperature": 0.7, "max_tokens": 1500, "top_p": 0.95}',
        'Default configuration for balanced performance',
        NOW()
    ),
    (
        (SELECT id FROM model WHERE model_name = 'GPT-4o'),
        '{"temperature": 0.1, "max_tokens": 4000, "top_p": 0.8}',
        'Academic configuration optimized for detailed explanations',
        NOW()
    );

-- Claude 3 Opus configurations
INSERT INTO model_configuration (model_id, model_config, comment, created_at)
VALUES
    (
        (SELECT id FROM model WHERE model_name = 'Claude 3 Opus'),
        '{"temperature": 0.7, "max_tokens": 1024, "top_p": 0.9}',
        'Balanced configuration for general usage',
        NOW()
    ),
    (
        (SELECT id FROM model WHERE model_name = 'Claude 3 Opus'),
        '{"temperature": 0.3, "max_tokens": 2000, "top_p": 0.85, "top_k": 40}',
        'Precise configuration for technical content',
        NOW()
    );

-- Claude 3 Sonnet configurations
INSERT INTO model_configuration (model_id, model_config, comment, created_at)
VALUES
    (
        (SELECT id FROM model WHERE model_name = 'Claude 3 Sonnet'),
        '{"temperature": 0.7, "max_tokens": 1024, "top_p": 0.9}',
        'Default configuration for everyday use',
        NOW()
    );

-- Llama-3-70b configurations
INSERT INTO model_configuration (model_id, model_config, comment, created_at)
VALUES
    (
        (SELECT id FROM model WHERE model_name = 'Llama-3-70b'),
        '{"temperature": 0.8, "max_tokens": 1024, "top_p": 0.9, "repetition_penalty": 1.1}',
        'Default open source model configuration',
        NOW()
    );

-----------

>>> ./docker/postgres/init/subscripts/model_parameter.sql
-- GPT-3.5-Turbo parameters
INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
VALUES
    ((SELECT id FROM model WHERE model_name = 'GPT-3.5-Turbo'), 'temperature', 'Controls randomness: Lowering results in less random completions', 'float', '0', '2', '0.7', 1),
    ((SELECT id FROM model WHERE model_name = 'GPT-3.5-Turbo'), 'max_tokens', 'The maximum number of tokens in the response', 'integer', '1', '4096', '1024', 2),
    ((SELECT id FROM model WHERE model_name = 'GPT-3.5-Turbo'), 'top_p', 'Controls diversity via nucleus sampling', 'float', '0', '1', '0.95', 3),
    ((SELECT id FROM model WHERE model_name = 'GPT-3.5-Turbo'), 'presence_penalty', 'Penalizes repeated tokens', 'float', '-2', '2', '0', 4),
    ((SELECT id FROM model WHERE model_name = 'GPT-3.5-Turbo'), 'frequency_penalty', 'Penalizes frequent tokens', 'float', '-2', '2', '0', 5);

-- GPT-4o parameters
INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
VALUES
    ((SELECT id FROM model WHERE model_name = 'GPT-4o'), 'temperature', 'Controls randomness: Lowering results in less random completions', 'float', '0', '2', '0.7', 1),
    ((SELECT id FROM model WHERE model_name = 'GPT-4o'), 'max_tokens', 'The maximum number of tokens in the response', 'integer', '1', '8192', '1024', 2),
    ((SELECT id FROM model WHERE model_name = 'GPT-4o'), 'top_p', 'Controls diversity via nucleus sampling', 'float', '0', '1', '0.95', 3),
    ((SELECT id FROM model WHERE model_name = 'GPT-4o'), 'presence_penalty', 'Penalizes repeated tokens', 'float', '-2', '2', '0', 4),
    ((SELECT id FROM model WHERE model_name = 'GPT-4o'), 'frequency_penalty', 'Penalizes frequent tokens', 'float', '-2', '2', '0', 5);

-- Claude 3 Opus parameters
INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
VALUES
    ((SELECT id FROM model WHERE model_name = 'Claude 3 Opus'), 'temperature', 'Controls randomness in generation', 'float', '0', '1', '0.7', 1),
    ((SELECT id FROM model WHERE model_name = 'Claude 3 Opus'), 'max_tokens', 'Maximum tokens to generate', 'integer', '1', '4096', '1024', 2),
    ((SELECT id FROM model WHERE model_name = 'Claude 3 Opus'), 'top_p', 'Nucleus sampling parameter', 'float', '0', '1', '0.9', 3),
    ((SELECT id FROM model WHERE model_name = 'Claude 3 Opus'), 'top_k', 'Limits vocabulary to top K tokens', 'integer', '1', '500', '50', 4);

-- Claude 3 Sonnet parameters
INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
VALUES
    ((SELECT id FROM model WHERE model_name = 'Claude 3 Sonnet'), 'temperature', 'Controls randomness in generation', 'float', '0', '1', '0.7', 1),
    ((SELECT id FROM model WHERE model_name = 'Claude 3 Sonnet'), 'max_tokens', 'Maximum tokens to generate', 'integer', '1', '4096', '1024', 2),
    ((SELECT id FROM model WHERE model_name = 'Claude 3 Sonnet'), 'top_p', 'Nucleus sampling parameter', 'float', '0', '1', '0.9', 3),
    ((SELECT id FROM model WHERE model_name = 'Claude 3 Sonnet'), 'top_k', 'Limits vocabulary to top K tokens', 'integer', '1', '500', '50', 4);

-- Llama-3-70b parameters
INSERT INTO model_parameter (model_id, param_name, description, data_type, min_value, max_value, default_value, display_order)
VALUES
    ((SELECT id FROM model WHERE model_name = 'Llama-3-70b'), 'temperature', 'Controls randomness', 'float', '0', '2', '0.8', 1),
    ((SELECT id FROM model WHERE model_name = 'Llama-3-70b'), 'max_tokens', 'Maximum tokens to generate', 'integer', '1', '4096', '1024', 2),
    ((SELECT id FROM model WHERE model_name = 'Llama-3-70b'), 'top_p', 'Nucleus sampling parameter', 'float', '0', '1', '0.9', 3),
    ((SELECT id FROM model WHERE model_name = 'Llama-3-70b'), 'repetition_penalty', 'Penalizes repetition', 'float', '1', '2', '1.1', 4);

-----------

>>> ./docker/postgres/init/subscripts/ranked_books.sql
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,1,'My Brilliant Friend','Elena Ferrante',2012);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,2,'The Warmth of Other Suns','Isabel Wilkerson',2010);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,3,'Wolf Hall','Hilary Mantel',2009);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,4,'The Known World','Edward P. Jones',2003);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,5,'The Corrections','Jonathan Franzen',2001);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,6,'2666','Roberto Bolaño',2008);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,7,'The Underground Railroad','Colson Whitehead',2016);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,8,'Austerlitz','W.G. Sebald',2001);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,9,'Never Let Me Go','Kazuo Ishiguro',2005);
INSERT INTO ranked_books (list_id, rank, title, author_name, publish_year) VALUES (1,10,'Gilead','Marilynne Robinson',2004);

-----------

>>> ./docker/postgres/init/subscripts/schema.sql
CREATE SEQUENCE messages_id_seq;
CREATE SEQUENCE model_id_seq;
CREATE SEQUENCE model_configuration_id_seq;
CREATE SEQUENCE model_parameter_id_seq;
CREATE SEQUENCE model_calls_id_seq;

DROP TABLE IF EXISTS model_calls CASCADE;
DROP TABLE IF EXISTS summaries CASCADE;
DROP TABLE IF EXISTS relationships CASCADE;
DROP TABLE IF EXISTS item_summary CASCADE;
DROP TABLE IF EXISTS model_parameter CASCADE;
DROP TABLE IF EXISTS model_configuration CASCADE;
DROP TABLE IF EXISTS items CASCADE;
DROP TABLE IF EXISTS model CASCADE;
DROP TABLE IF EXISTS messages CASCADE;

CREATE TABLE messages
(
    id         bigint                   NOT NULL DEFAULT nextval('messages_id_seq'::regclass),
    content    text,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT messages_pkey PRIMARY KEY (id)
);

CREATE TABLE model
(
    id             bigint       NOT NULL DEFAULT nextval('model_id_seq'::regclass),
    model_name     varchar(200) NOT NULL,
    model_provider varchar(200) NOT NULL,
    model_api_url  varchar(500),
    comment        text,
    CONSTRAINT model_pkey PRIMARY KEY (id),
    CONSTRAINT model_name_provider_unique UNIQUE (model_name, model_provider)
);

CREATE TABLE model_configuration
(
    id           bigint                   NOT NULL DEFAULT nextval('model_configuration_id_seq'::regclass),
    model_id     bigint                   NOT NULL,
    model_config jsonb                    NOT NULL DEFAULT '{}',
    comment      text,
    created_at   timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT model_configuration_pkey PRIMARY KEY (id),
    CONSTRAINT model_configuration_model_id_fkey FOREIGN KEY (model_id)
        REFERENCES model (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
);

CREATE TABLE model_parameter
(
    id            bigint       NOT NULL DEFAULT nextval('model_parameter_id_seq'::regclass),
    model_id      bigint       NOT NULL,
    param_name    varchar(100) NOT NULL,
    description   text,
    data_type     varchar(50)  NOT NULL DEFAULT 'string',
    min_value     varchar(50),
    max_value     varchar(50),
    default_value varchar(100),
    display_order integer               DEFAULT 0,
    CONSTRAINT model_parameter_pkey PRIMARY KEY (id),
    CONSTRAINT model_parameter_model_id_fkey FOREIGN KEY (model_id)
        REFERENCES model (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT model_parameter_model_id_param_name_key UNIQUE (model_id, param_name)
);

CREATE TABLE items
(
    id           BIGSERIAL PRIMARY KEY,
    item_type    VARCHAR(100)             NOT NULL,
    name         VARCHAR(500)             NOT NULL,
    description  TEXT,
    creator      VARCHAR(255), -- author, director, researcher, etc.
    created_year VARCHAR(10),  -- publish year, release year, etc.
    external_id  VARCHAR(255), -- ISBN, DOI, IMDB ID, etc.
    source       VARCHAR(255), -- where this item came from
    attributes   JSONB                    NOT NULL DEFAULT '{}',
    created_at   TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at   TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE TABLE relationships
(
    id                bigserial PRIMARY KEY,
    name              varchar(255)             NOT NULL,
    relationship_type varchar(100)             NOT NULL,
    source_item_id    bigint                   NOT NULL,
    target_item_id    bigint                   NOT NULL,
    attributes        jsonb                    NOT NULL DEFAULT '{}',
    created_at        timestamp with time zone NOT NULL DEFAULT now(),
    updated_at        timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT relationships_source_item_fkey FOREIGN KEY (source_item_id)
        REFERENCES items (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT relationships_target_item_fkey FOREIGN KEY (target_item_id)
        REFERENCES items (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
);

CREATE TABLE summaries
(
    id                     bigserial PRIMARY KEY,
    name                   varchar(255)             NOT NULL,
    batch_id               bigint,
    model_configuration_id bigint,
    item_id                bigint                   NOT NULL,
    content                text,
    source                 varchar(255),
    attributes             jsonb                    NOT NULL DEFAULT '{}',
    created_at             timestamp with time zone NOT NULL DEFAULT now(),
    updated_at             timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT summaries_model_configuration_id_fkey FOREIGN KEY (model_configuration_id)
        REFERENCES model_configuration (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE SET NULL,
    CONSTRAINT summaries_item_id_fkey FOREIGN KEY (item_id)
        REFERENCES items (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
);

CREATE TABLE model_calls
(
    id                       bigint                   NOT NULL DEFAULT nextval('model_calls_id_seq'::regclass),
    model_configuration_id   bigint,
    model_configuration_json jsonb,
    provider                 varchar(255),
    prompt_text              text,
    prompt_json              jsonb,
    response_text            text,
    response_json            jsonb,
    token_usage              jsonb,
    chat_options             jsonb,
    metadata                 jsonb,
    success                  boolean                  NOT NULL DEFAULT false,
    error_message            text,
    error_class              varchar(255),
    error_stacktrace         text,
    start_time               timestamp with time zone,
    end_time                 timestamp with time zone,
    duration_ms              bigint,
    api_duration_ms          bigint,
    processing_duration_ms   bigint,
    batch_id                 bigint,
    created_at               timestamp with time zone NOT NULL DEFAULT now(),
    model_name               varchar(255),
    model_provider           varchar(255),
    correlation_id           varchar(255),
    user_id                  varchar(255),
    request_context          varchar(255),
    CONSTRAINT model_calls_pkey PRIMARY KEY (id),
    CONSTRAINT model_calls_model_configuration_id_fkey FOREIGN KEY (model_configuration_id)
        REFERENCES model_configuration (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE SET NULL
);

-- Indexes for performance
CREATE INDEX idx_items_type ON items (item_type);
CREATE INDEX idx_items_name ON items (name);
CREATE INDEX idx_items_creator ON items (creator);
CREATE INDEX idx_items_created_year ON items (created_year);
CREATE INDEX idx_items_external_id ON items (external_id);
CREATE INDEX idx_items_source ON items (source);
CREATE INDEX idx_items_attributes ON items USING GIN (attributes);

-- Combined indexes for common query patterns
CREATE INDEX idx_items_type_name ON items (item_type, name);
CREATE INDEX idx_items_type_creator ON items (item_type, creator);

-- Summaries indexes - updated for simplified structure
CREATE INDEX idx_summaries_item_id ON summaries (item_id);
CREATE INDEX idx_summaries_batch ON summaries (batch_id) WHERE batch_id IS NOT NULL;
CREATE INDEX idx_summaries_model_config ON summaries (model_configuration_id);

-- Relationships indexes - updated for item-based structure
CREATE INDEX idx_relationships_type ON relationships (relationship_type);
CREATE INDEX idx_relationships_source ON relationships (source_item_id);
CREATE INDEX idx_relationships_target ON relationships (target_item_id);
CREATE INDEX idx_relationships_source_target ON relationships (source_item_id, target_item_id);

-- Model calls performance indexes
CREATE INDEX idx_model_calls_config_id ON model_calls (model_configuration_id);
CREATE INDEX idx_model_calls_batch_id ON model_calls (batch_id) WHERE batch_id IS NOT NULL;
CREATE INDEX idx_model_calls_created_at ON model_calls (created_at DESC);
CREATE INDEX idx_model_calls_success ON model_calls (success);
CREATE INDEX idx_model_calls_duration ON model_calls (duration_ms) WHERE success = true;
CREATE INDEX idx_model_calls_model_name ON model_calls (model_name);
CREATE INDEX idx_model_calls_model_provider ON model_calls (model_provider);
CREATE INDEX idx_model_calls_correlation_id ON model_calls (correlation_id);
CREATE INDEX idx_model_calls_user_id ON model_calls (user_id) WHERE user_id IS NOT NULL;
CREATE INDEX idx_model_calls_request_context ON model_calls (request_context);

-- Performance analysis composite indexes
CREATE INDEX idx_model_calls_provider_success_time ON model_calls (model_provider, success, created_at DESC);
CREATE INDEX idx_model_calls_batch_performance ON model_calls (batch_id, success, duration_ms) WHERE batch_id IS NOT NULL;

-- JSONB indexes for efficient querying
CREATE INDEX idx_summaries_attributes ON summaries USING GIN (attributes);
CREATE INDEX idx_relationships_attributes ON relationships USING GIN (attributes);
CREATE INDEX idx_model_calls_token_usage ON model_calls USING GIN (token_usage);
CREATE INDEX idx_model_calls_chat_options ON model_calls USING GIN (chat_options);
CREATE INDEX idx_model_calls_metadata ON model_calls USING GIN (metadata);
CREATE INDEX idx_model_calls_response_json ON model_calls USING GIN (response_json);

-- Comments for documentation
COMMENT
ON TABLE items IS 'Unified table for all item types (books, movies, papers, people, etc.)';
COMMENT
ON COLUMN items.item_type IS 'Type of item: book, movie, person, paper, collection, etc.';
COMMENT
ON COLUMN items.name IS 'Primary name/title of the item';
COMMENT
ON COLUMN items.description IS 'Optional description or summary of the item';
COMMENT
ON COLUMN items.creator IS 'Creator of the item (author, director, researcher, etc.)';
COMMENT
ON COLUMN items.created_year IS 'Year the item was created/published/released';
COMMENT
ON COLUMN items.external_id IS 'External identifier (ISBN, DOI, IMDB ID, etc.)';
COMMENT
ON COLUMN items.source IS 'Source where this item data came from';
COMMENT
ON COLUMN items.attributes IS 'Type-specific attributes stored as JSON';

COMMENT
ON TABLE relationships IS 'Relationships between items using unified item IDs';
COMMENT
ON COLUMN relationships.source_item_id IS 'Source item ID from items table';
COMMENT
ON COLUMN relationships.target_item_id IS 'Target item ID from items table';

COMMENT
ON TABLE summaries IS 'Summaries of items using unified item IDs';
COMMENT
ON COLUMN summaries.item_id IS 'Item ID from items table';

-- Column comments for model calls
COMMENT
ON COLUMN model_calls.model_configuration_json IS 'Snapshot of model configuration at execution time';
COMMENT
ON COLUMN model_calls.chat_options IS 'Complete ChatOptions object captured via introspection';
COMMENT
ON COLUMN model_calls.metadata IS 'Additional request/response metadata (headers, rate limits, etc.)';
COMMENT
ON COLUMN model_calls.api_duration_ms IS 'Network/API call duration only';
COMMENT
ON COLUMN model_calls.processing_duration_ms IS 'Local processing duration (serialization, etc.)';
COMMENT
ON COLUMN model_calls.correlation_id IS 'Request correlation ID for distributed tracing';
COMMENT
ON COLUMN model_calls.request_context IS 'Source context (batch_summary, chat, operations, etc.)';

-- Table comments
COMMENT
ON TABLE model_calls IS 'Comprehensive logging of all AI model API interactions';
COMMENT
ON TABLE summaries IS 'Unified summary table for all item types';
COMMENT
ON TABLE item_summary IS 'Legacy summary table - migrate to summaries table';

-- Triggers for updated_at timestamps
CREATE
OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at
= now();
RETURN NEW;
END;
$$
language 'plpgsql';

CREATE TRIGGER update_items_updated_at
    BEFORE UPDATE
    ON items
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_relationships_updated_at
    BEFORE UPDATE
    ON relationships
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_summaries_updated_at
    BEFORE UPDATE
    ON summaries
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-----------

>>> ./backend/.mvn/wrapper/MavenWrapperDownloader.java
/*
 * Copyright 2007-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.net.*;
import java.io.*;
import java.nio.channels.*;
import java.util.Properties;

public class MavenWrapperDownloader {

    private static final String WRAPPER_VERSION = "0.5.6";
    /**
     * Default URL to download the maven-wrapper.jar from, if no 'downloadUrl' is provided.
     */
    private static final String DEFAULT_DOWNLOAD_URL = "https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/"
        + WRAPPER_VERSION + "/maven-wrapper-" + WRAPPER_VERSION + ".jar";

    /**
     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to
     * use instead of the default one.
     */
    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =
            ".mvn/wrapper/maven-wrapper.properties";

    /**
     * Path where the maven-wrapper.jar will be saved to.
     */
    private static final String MAVEN_WRAPPER_JAR_PATH =
            ".mvn/wrapper/maven-wrapper.jar";

    /**
     * Name of the property which should be used to override the default download url for the wrapper.
     */
    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";

    public static void main(String args[]) {
        System.out.println("- Downloader started");
        File baseDirectory = new File(args[0]);
        System.out.println("- Using base directory: " + baseDirectory.getAbsolutePath());

        // If the maven-wrapper.properties exists, read it and check if it contains a custom
        // wrapperUrl parameter.
        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);
        String url = DEFAULT_DOWNLOAD_URL;
        if(mavenWrapperPropertyFile.exists()) {
            FileInputStream mavenWrapperPropertyFileInputStream = null;
            try {
                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
                Properties mavenWrapperProperties = new Properties();
                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
            } catch (IOException e) {
                System.out.println("- ERROR loading '" + MAVEN_WRAPPER_PROPERTIES_PATH + "'");
            } finally {
                try {
                    if(mavenWrapperPropertyFileInputStream != null) {
                        mavenWrapperPropertyFileInputStream.close();
                    }
                } catch (IOException e) {
                    // Ignore ...
                }
            }
        }
        System.out.println("- Downloading from: " + url);

        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);
        if(!outputFile.getParentFile().exists()) {
            if(!outputFile.getParentFile().mkdirs()) {
                System.out.println(
                        "- ERROR creating output directory '" + outputFile.getParentFile().getAbsolutePath() + "'");
            }
        }
        System.out.println("- Downloading to: " + outputFile.getAbsolutePath());
        try {
            downloadFileFromURL(url, outputFile);
            System.out.println("Done");
            System.exit(0);
        } catch (Throwable e) {
            System.out.println("- Error downloading");
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static void downloadFileFromURL(String urlString, File destination) throws Exception {
        if (System.getenv("MVNW_USERNAME") != null && System.getenv("MVNW_PASSWORD") != null) {
            String username = System.getenv("MVNW_USERNAME");
            char[] password = System.getenv("MVNW_PASSWORD").toCharArray();
            Authenticator.setDefault(new Authenticator() {
                @Override
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }
            });
        }
        URL website = new URL(urlString);
        ReadableByteChannel rbc;
        rbc = Channels.newChannel(website.openStream());
        FileOutputStream fos = new FileOutputStream(destination);
        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
        fos.close();
        rbc.close();
    }

}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/advisor/ModelCallLoggingAdvisor.java
package net.sampsoftware.genai.advisor;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.model.ModelCall;
import net.sampsoftware.genai.model.ModelConfiguration;
import net.sampsoftware.genai.service.ModelCallService;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.prompt.ChatOptions;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.Arrays;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Aspect
@Component
@Slf4j
@RequiredArgsConstructor
public class ModelCallLoggingAdvisor {

    private final ObjectMapper objectMapper;
    private final ModelCallService modelCallService;

    @Around("execution(* org.springframework.ai.chat.client.ChatClient.*(..)) || " +
            "execution(* org.springframework.ai.chat.model.ChatModel.*(..))")
    public Object logModelCall(ProceedingJoinPoint joinPoint) throws Throwable {

        String correlationId = UUID.randomUUID().toString();
        Instant startTime = Instant.now();
        Instant apiStartTime = null;
        Instant apiEndTime = null;

        try {
            ModelCall.ModelCallBuilder callBuilder = ModelCall.builder()
                    .correlationId(correlationId)
                    .startTime(startTime)
                    .createdAt(Instant.now());

            Prompt prompt = extractPrompt(joinPoint.getArgs());
            ModelConfiguration modelConfig = extractModelConfiguration(joinPoint.getArgs());

            if (prompt != null) {
                callBuilder
                        .promptText(buildPromptText(prompt))
                        .promptJson(capturePromptJson(prompt))
                        .chatOptions(captureChatOptions(prompt.getOptions()));
            }

            if (modelConfig != null) {
                callBuilder
                        .modelConfiguration(modelConfig)
                        .modelConfigurationJson(captureModelConfiguration(modelConfig))
                        .modelName(modelConfig.getModel().getModelName())
                        .modelProvider(modelConfig.getModel().getModelProvider());
            }

            String provider = determineProvider(joinPoint.getTarget());
            callBuilder.provider(provider);

            String context = determineRequestContext();
            callBuilder.requestContext(context);

            // Execute the actual API call
            apiStartTime = Instant.now();
            Object result = joinPoint.proceed();
            apiEndTime = Instant.now();

            Instant endTime = Instant.now();

            if (result instanceof ChatResponse chatResponse) {
                callBuilder
                        .responseText(extractResponseText(chatResponse))
                        .responseJson(captureResponseJson(chatResponse))
                        .tokenUsage(captureTokenUsage(chatResponse))
                        .metadata(captureResponseMetadata(chatResponse));
            }

            long totalDuration = endTime.toEpochMilli() - startTime.toEpochMilli();
            long apiDuration = apiEndTime.toEpochMilli() - apiStartTime.toEpochMilli();
            long processingDuration = totalDuration - apiDuration;

            ModelCall modelCall = callBuilder
                    .endTime(endTime)
                    .durationMs(totalDuration)
                    .apiDurationMs(apiDuration)
                    .processingDurationMs(processingDuration)
                    .success(true)
                    .build();

            CompletableFuture.runAsync(() -> modelCallService.saveAsync(modelCall));

            log.debug("AI API call successful - correlation: {}, duration: {}ms, api: {}ms",
                    correlationId, totalDuration, apiDuration);

            return result;

        } catch (Exception e) {
            Instant endTime = Instant.now();
            long totalDuration = endTime.toEpochMilli() - startTime.toEpochMilli();
            long apiDuration = (apiStartTime != null && apiEndTime != null) ?
                    apiEndTime.toEpochMilli() - apiStartTime.toEpochMilli() : 0;

            ModelCall failedCall = ModelCall.builder()
                    .correlationId(correlationId)
                    .startTime(startTime)
                    .endTime(endTime)
                    .durationMs(totalDuration)
                    .apiDurationMs(apiDuration)
                    .processingDurationMs(totalDuration - apiDuration)
                    .success(false)
                    .errorMessage(e.getMessage())
                    .errorClass(e.getClass().getSimpleName())
                    .errorStacktrace(getStackTrace(e))
                    .provider(determineProvider(joinPoint.getTarget()))
                    .requestContext(determineRequestContext())
                    .build();

            CompletableFuture.runAsync(() -> modelCallService.saveAsync(failedCall));

            log.error("AI API call failed - correlation: {}, duration: {}ms: {}",
                    correlationId, totalDuration, e.getMessage());

            throw e;
        }
    }

    /**
     * Build human-readable prompt text from all message components
     */
    private String buildPromptText(Prompt prompt) {
        if (prompt == null || prompt.getInstructions() == null) {
            return null;
        }

        return prompt.getInstructions().stream()
                .map(message -> {
                    String messageType = message.getClass().getSimpleName().toUpperCase()
                            .replace("MESSAGE", "");
                    return messageType + ": " + message.getText();
                })
                .collect(Collectors.joining("\n"));
    }

    /**
     * Capture complete prompt structure - let Jackson handle the complexity
     */
    private JsonNode capturePromptJson(Prompt prompt) {
        try {
            ObjectNode promptNode = objectMapper.createObjectNode();

            // Messages - serialize each message safely
            if (prompt.getInstructions() != null) {
                promptNode.set("messages", objectMapper.valueToTree(
                        prompt.getInstructions().stream()
                                .map(this::captureMessage)
                                .collect(Collectors.toList())
                ));
            }

            // Options - let Jackson serialize the ChatOptions
            if (prompt.getOptions() != null) {
                promptNode.set("options", objectMapper.valueToTree(prompt.getOptions()));
            }

            // Add prompt-level metadata
            promptNode.put("messageCount", prompt.getInstructions() != null ? prompt.getInstructions().size() : 0);
            promptNode.put("hasOptions", prompt.getOptions() != null);

            return promptNode;
        } catch (Exception e) {
            log.warn("Failed to capture prompt JSON: {}", e.getMessage());
            ObjectNode errorNode = objectMapper.createObjectNode();
            errorNode.put("error", "capture_failed");
            errorNode.put("reason", e.getMessage());
            return errorNode;
        }
    }

    /**
     * Capture ChatOptions - trust Jackson to serialize provider-specific fields
     */
    private JsonNode captureChatOptions(ChatOptions options) {
        if (options == null) {
            return null;
        }

        try {
            // Jackson knows how to serialize Spring AI ChatOptions and its implementations
            JsonNode optionsJson = objectMapper.valueToTree(options);

            // Add metadata about the options type for debugging
            if (optionsJson.isObject()) {
                ((ObjectNode) optionsJson).put("_optionsType", options.getClass().getSimpleName());
            }

            return optionsJson;
        } catch (Exception e) {
            log.warn("Failed to capture chat options: {}", e.getMessage());
            ObjectNode errorNode = objectMapper.createObjectNode();
            errorNode.put("error", "capture_failed");
            errorNode.put("optionsType", options.getClass().getSimpleName());
            errorNode.put("reason", e.getMessage());
            return errorNode;
        }
    }

    /**
     * Capture complete ChatResponse - again, trust Jackson
     */
    private JsonNode captureResponseJson(ChatResponse response) {
        try {
            // Let Jackson serialize the entire response
            JsonNode responseJson = objectMapper.valueToTree(response);

            // Add response-level metadata
            if (responseJson.isObject()) {
                ObjectNode responseNode = (ObjectNode) responseJson;
                responseNode.put("_responseType", response.getClass().getSimpleName());
                responseNode.put("_resultCount", response.getResults() != null ? response.getResults().size() : 0);
            }

            return responseJson;
        } catch (Exception e) {
            log.warn("Failed to capture response JSON: {}", e.getMessage());
            ObjectNode errorNode = objectMapper.createObjectNode();
            errorNode.put("error", "capture_failed");
            errorNode.put("responseType", response.getClass().getSimpleName());
            errorNode.put("reason", e.getMessage());
            return errorNode;
        }
    }

    /**
     * Capture individual message safely
     */
    private JsonNode captureMessage(Message message) {
        try {
            ObjectNode messageNode = objectMapper.createObjectNode();
            messageNode.put("messageType", message.getClass().getSimpleName());
            messageNode.put("text", message.getText());

            // Try to capture additional message properties via Jackson
            JsonNode fullMessage = objectMapper.valueToTree(message);
            if (fullMessage.isObject()) {
                fullMessage.fields().forEachRemaining(entry -> {
                    if (!entry.getKey().equals("text")) { // Don't duplicate the text field
                        messageNode.set(entry.getKey(), entry.getValue());
                    }
                });
            }

            return messageNode;
        } catch (Exception e) {
            log.debug("Could not fully capture message: {}", e.getMessage());
            ObjectNode simpleMessage = objectMapper.createObjectNode();
            simpleMessage.put("messageType", message.getClass().getSimpleName());
            simpleMessage.put("text", message.getText());
            simpleMessage.put("_captureError", e.getMessage());
            return simpleMessage;
        }
    }

    private JsonNode captureTokenUsage(ChatResponse response) {
        try {
            if (response.getMetadata() != null && response.getMetadata().getUsage() != null) {
                return objectMapper.valueToTree(response.getMetadata().getUsage());
            }
        } catch (Exception e) {
            log.debug("Could not capture token usage: {}", e.getMessage());
        }
        return null;
    }

    private JsonNode captureResponseMetadata(ChatResponse response) {
        try {
            ObjectNode metadataNode = objectMapper.createObjectNode();

            if (response.getMetadata() != null) {
                metadataNode.set("responseMetadata", objectMapper.valueToTree(response.getMetadata()));
            }

            // Add our own metadata
            metadataNode.put("resultCount", response.getResults() != null ? response.getResults().size() : 0);
            metadataNode.put("captureTime", Instant.now().toString());
            metadataNode.put("responseClass", response.getClass().getSimpleName());

            return metadataNode;
        } catch (Exception e) {
            log.debug("Could not capture response metadata: {}", e.getMessage());
            ObjectNode errorNode = objectMapper.createObjectNode();
            errorNode.put("error", "metadata_capture_failed");
            errorNode.put("reason", e.getMessage());
            return errorNode;
        }
    }

    private JsonNode captureModelConfiguration(ModelConfiguration config) {
        try {
            ObjectNode configNode = objectMapper.createObjectNode();
            configNode.put("id", config.getId());
            configNode.put("comment", config.getComment());
            configNode.put("createdAt", config.getCreatedAt().toString());
            configNode.set("modelConfig", config.getModelConfig());
            configNode.put("modelName", config.getModel().getModelName());
            configNode.put("modelProvider", config.getModel().getModelProvider());
            configNode.put("modelApiUrl", config.getModel().getModelApiUrl());

            return configNode;
        } catch (Exception e) {
            log.warn("Could not capture model configuration: {}", e.getMessage());
            ObjectNode errorNode = objectMapper.createObjectNode();
            errorNode.put("error", "config_capture_failed");
            errorNode.put("configId", config != null ? config.getId() : null);
            return errorNode;
        }
    }

    private String extractResponseText(ChatResponse response) {
        try {
            if (response.getResults() != null && !response.getResults().isEmpty()) {
                return response.getResults().get(0).getOutput().getText();
            }
        } catch (Exception e) {
            log.debug("Could not extract response text: {}", e.getMessage());
        }
        return null;
    }

    private String determineProvider(Object target) {
        String className = target.getClass().getSimpleName().toLowerCase();
        if (className.contains("openai")) return "openai";
        if (className.contains("ollama")) return "ollama";
        if (className.contains("anthropic")) return "anthropic";
        if (className.contains("azure")) return "azure";
        return "unknown";
    }

    private String determineRequestContext() {
        StackTraceElement[] stack = Thread.currentThread().getStackTrace();
        for (StackTraceElement element : stack) {
            if (element.getClassName().contains("sampsoftware.genai.service")) {
                return element.getClassName().substring(element.getClassName().lastIndexOf('.') + 1);
            }
        }
        return "unknown";
    }

    private Prompt extractPrompt(Object[] args) {
        return Arrays.stream(args)
                .filter(Prompt.class::isInstance)
                .map(Prompt.class::cast)
                .findFirst()
                .orElse(null);
    }

    private ModelConfiguration extractModelConfiguration(Object[] args) {
        // This would need to be enhanced based on how you pass model configuration
        // Could be via thread local, request context, or method parameter
        return null;
    }

    private String getStackTrace(Exception e) {
        return Arrays.stream(e.getStackTrace())
                .limit(10)
                .map(StackTraceElement::toString)
                .collect(Collectors.joining("\n"));
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/config/AsyncConfig.java
package net.sampsoftware.genai.config;

import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.aop.interceptor.SimpleAsyncUncaughtExceptionHandler;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;

@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix("book-processor-");
        executor.initialize();
        return executor;
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new SimpleAsyncUncaughtExceptionHandler();
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/config/WebConfig.java
package net.sampsoftware.genai.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.filter.CommonsRequestLoggingFilter;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    @SuppressWarnings("null")
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:3000")
                .allowedMethods("*")
                .allowedHeaders("*");
    }
    
    @Bean
    public CommonsRequestLoggingFilter requestLoggingFilter() {
        CommonsRequestLoggingFilter filter = new CommonsRequestLoggingFilter();
        filter.setIncludeQueryString(true);
        filter.setIncludePayload(true);
        filter.setMaxPayloadLength(10000);
        filter.setBeforeMessagePrefix("REQUEST DATA : ");
        filter.setAfterMessagePrefix("RESPONSE DATA : ");
        return filter;
    }
}
-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/controller/BatchSummaryController.java
package net.sampsoftware.genai.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.dto.BatchSummaryRequest;
import net.sampsoftware.genai.dto.BatchSummaryResponse;
import net.sampsoftware.genai.service.AsyncItemSummaryService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api/batch-summary")
@RequiredArgsConstructor
public class BatchSummaryController {

    private final AsyncItemSummaryService itemSummaryService;

    /**
     * Generate summaries for all items of specified types
     */
    @PostMapping
    public ResponseEntity<BatchSummaryResponse> generateSummaries(@RequestBody BatchSummaryRequest request) {
        log.debug("Starting batch summary generation with model config {}", request.modelConfigurationId());

        try {
            BatchSummaryResponse response = itemSummaryService.generateSummariesForAllItems(
                    request.prompt(),
                    request.modelConfigurationId(),
                    request.itemTypes()
            );

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error generating batch summaries: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError()
                    .body(new BatchSummaryResponse(0, 1, List.of(), e.getMessage()));
        }
    }

    /**
     * Generate summaries for specific items by ID
     */
    @PostMapping("/items")
    public ResponseEntity<BatchSummaryResponse> generateSummariesForItems(
            @RequestBody BatchSummaryForItemsRequest request) {

        log.debug("Starting batch summary generation for {} specific items", request.itemIds().size());

        try {
            BatchSummaryResponse response = itemSummaryService.generateSummariesForItems(
                    request.itemIds(),
                    request.prompt(),
                    request.modelConfigurationId()
            );

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error generating summaries for specific items: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError()
                    .body(new BatchSummaryResponse(0, 1, List.of(), e.getMessage()));
        }
    }

    /**
     * Generate summaries for items in a collection
     */
    @PostMapping("/collection/{collectionId}")
    public ResponseEntity<BatchSummaryResponse> generateSummariesForCollection(
            @PathVariable Long collectionId,
            @RequestBody BatchSummaryForCollectionRequest request) {

        log.debug("Starting batch summary generation for collection {}", collectionId);

        try {
            BatchSummaryResponse response = itemSummaryService.generateSummariesForCollection(
                    collectionId,
                    request.prompt(),
                    request.modelConfigurationId()
            );

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error generating summaries for collection {}: {}", collectionId, e.getMessage(), e);
            return ResponseEntity.internalServerError()
                    .body(new BatchSummaryResponse(0, 1, List.of(), e.getMessage()));
        }
    }

    // Request DTOs

    /**
     * Request for summarizing specific items
     */
    record BatchSummaryForItemsRequest(
            List<Long> itemIds,
            String prompt,
            Long modelConfigurationId
    ) {}

    /**
     * Request for summarizing items in a collection
     */
    record BatchSummaryForCollectionRequest(
            String prompt,
            Long modelConfigurationId
    ) {}
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/controller/ChatController.java
package net.sampsoftware.genai.controller;

import net.sampsoftware.genai.dto.ChatRequest;
import net.sampsoftware.genai.dto.ChatResponse;
import net.sampsoftware.genai.service.ChatService;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/chat")
public class ChatController {

    private final ChatService chatService;
    public ChatController(ChatService chatService) {
        this.chatService = chatService;
    }

    @PostMapping
    public ChatResponse chat(@RequestBody ChatRequest request) {
        String reply = chatService.chat(request.getContent());
        return new ChatResponse(reply);
    }

}


-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/controller/CrudDtoController.java
package net.sampsoftware.genai.controller;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

public abstract class CrudDtoController<T, D, ID> {

    protected abstract JpaRepository<T, ID> getRepository();
    protected abstract D toDto(T entity);
    protected abstract T toEntity(D dto);

    @GetMapping
    public List<D> list() {
        return getRepository().findAll().stream()
                .map(this::toDto)
                .collect(Collectors.toList());
    }

    @GetMapping("/{id}")
    public ResponseEntity<D> get(@PathVariable ID id) {
        Optional<T> result = getRepository().findById(id);
        return result.map(t -> ResponseEntity.ok(toDto(t)))
                .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    public ResponseEntity<D> create(@RequestBody D dto) {
        T saved = getRepository().save(toEntity(dto));
        return ResponseEntity.ok(toDto(saved));
    }

    @PutMapping("/{id}")
    public ResponseEntity<D> update(@PathVariable ID id, @RequestBody D dto) {
        if (!getRepository().existsById(id)) {
            return ResponseEntity.notFound().build();
        }
        T updated = toEntity(dto);
        return ResponseEntity.ok(toDto(getRepository().save(updated)));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable ID id) {
        if (!getRepository().existsById(id)) {
            return ResponseEntity.notFound().build();
        }
        getRepository().deleteById(id);
        return ResponseEntity.noContent().build();
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/controller/CytoscapeController.java
package net.sampsoftware.genai.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.dto.CytoscapeDto;
import net.sampsoftware.genai.service.CytoscapeService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api/cytoscape")
@RequiredArgsConstructor
public class CytoscapeController {

    private final CytoscapeService cytoscapeService;

    /**
     * Get graph of all items and their summaries
     */
    @GetMapping("/items-summaries")
    public ResponseEntity<CytoscapeDto> getItemsSummariesGraph() {
        log.debug("Requested items-summaries graph");
        try {
            CytoscapeDto graph = cytoscapeService.getItemsSummariesGraph();
            return ResponseEntity.ok(graph);
        } catch (Exception e) {
            log.error("Error generating items-summaries graph: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get graph showing relationships between items
     */
    @GetMapping("/items-relationships")
    public ResponseEntity<CytoscapeDto> getItemsRelationshipsGraph() {
        log.debug("Requested items-relationships graph");
        try {
            CytoscapeDto graph = cytoscapeService.getItemsRelationshipsGraph();
            return ResponseEntity.ok(graph);
        } catch (Exception e) {
            log.error("Error generating items-relationships graph: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get graph for a specific collection of items
     */
    @GetMapping("/collection/{collectionId}")
    public ResponseEntity<CytoscapeDto> getCollectionGraph(@PathVariable Long collectionId) {
        log.debug("Requested collection graph for collection {}", collectionId);
        try {
            CytoscapeDto graph = cytoscapeService.getCollectionGraph(collectionId);
            return ResponseEntity.ok(graph);
        } catch (Exception e) {
            log.error("Error generating collection graph for {}: {}", collectionId, e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get graph filtered by item types
     */
    @GetMapping("/items-by-type")
    public ResponseEntity<CytoscapeDto> getGraphByItemTypes(
            @RequestParam List<String> itemTypes,
            @RequestParam(defaultValue = "false") boolean includeRelationships) {

        log.debug("Requested graph for item types: {} (relationships: {})", itemTypes, includeRelationships);
        try {
            CytoscapeDto graph = cytoscapeService.getGraphByItemTypes(itemTypes, includeRelationships);
            return ResponseEntity.ok(graph);
        } catch (Exception e) {
            log.error("Error generating graph for item types {}: {}", itemTypes, e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get graph for items with summaries from a specific model
     */
    @GetMapping("/model/{modelId}")
    public ResponseEntity<CytoscapeDto> getGraphByModel(@PathVariable Long modelId) {
        log.debug("Requested graph for model {}", modelId);
        try {
            CytoscapeDto graph = cytoscapeService.getGraphByModel(modelId);
            return ResponseEntity.ok(graph);
        } catch (Exception e) {
            log.error("Error generating graph for model {}: {}", modelId, e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get comprehensive graph with items, summaries, and relationships
     */
    @GetMapping("/comprehensive")
    public ResponseEntity<CytoscapeDto> getComprehensiveGraph(
            @RequestParam(defaultValue = "100") int maxItems,
            @RequestParam(required = false) List<String> itemTypes) {

        log.debug("Requested comprehensive graph (maxItems: {}, types: {})", maxItems, itemTypes);
        try {
            CytoscapeDto graph = cytoscapeService.getComprehensiveGraph(maxItems, itemTypes);
            return ResponseEntity.ok(graph);
        } catch (Exception e) {
            log.error("Error generating comprehensive graph: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get available item types for filtering
     */
    @GetMapping("/item-types")
    public ResponseEntity<List<String>> getAvailableItemTypes() {
        log.debug("Requested available item types");
        try {
            List<String> itemTypes = cytoscapeService.getAvailableItemTypes();
            return ResponseEntity.ok(itemTypes);
        } catch (Exception e) {
            log.error("Error getting available item types: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get statistics about the graph data
     */
    @GetMapping("/stats")
    public ResponseEntity<GraphStats> getGraphStats() {
        log.debug("Requested graph statistics");
        try {
            GraphStats stats = cytoscapeService.getGraphStats();
            return ResponseEntity.ok(stats);
        } catch (Exception e) {
            log.error("Error getting graph stats: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Statistics about the graph data
     */
    public record GraphStats(
            int totalItems,
            int totalSummaries,
            int totalRelationships,
            int totalCollections,
            List<ItemTypeCount> itemTypeCounts
    ) {}

    /**
     * Count of items by type
     */
    public record ItemTypeCount(
            String itemType,
            int count
    ) {}
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/controller/MessageController.java
// MessageController.java
package net.sampsoftware.genai.controller;

import net.sampsoftware.genai.model.Message;
import net.sampsoftware.genai.repository.MessageRepository;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/messages")
public class MessageController {
    private final MessageRepository repo;
    public MessageController(MessageRepository repo) { this.repo = repo; }

    @GetMapping public List<Message> all() { return repo.findAll(); }
    @PostMapping public Message create(@RequestBody Message m) { return repo.save(m); }
    @DeleteMapping("/{id}") public void delete(@PathVariable Long id) { repo.deleteById(id); }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/controller/ModelConfigurationController.java
package net.sampsoftware.genai.controller;

import lombok.RequiredArgsConstructor;
import net.sampsoftware.genai.dto.ModelConfigurationDto;
import net.sampsoftware.genai.mapper.ModelConfigurationMapper;
import net.sampsoftware.genai.model.ModelConfiguration;
import net.sampsoftware.genai.repository.ModelConfigurationRepository;

import org.springframework.http.ResponseEntity;

import java.util.List;
import java.util.stream.Collectors;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/model-configurations")
@RequiredArgsConstructor
public class ModelConfigurationController extends CrudDtoController<ModelConfiguration, ModelConfigurationDto, Long> {

    private final ModelConfigurationRepository configRepository;
    private final ModelConfigurationMapper configMapper;

    @Override
    protected JpaRepository<ModelConfiguration, Long> getRepository() {
        return configRepository;
    }

    @Override
    protected ModelConfigurationDto toDto(ModelConfiguration entity) {
        return configMapper.toDto(entity);
    }

    @Override
    protected ModelConfiguration toEntity(ModelConfigurationDto dto) {
        return configMapper.toEntity(dto);
    }

    @Override
    @GetMapping("/{id}")
    public ResponseEntity<ModelConfigurationDto> get(@PathVariable Long id) {
        var config = configRepository.findByIdWithModel(id);
        return config
            .map(configMapper::toDto)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @Override
    @GetMapping
    public List<ModelConfigurationDto> list() {
        var entities = ((ModelConfigurationRepository)getRepository()).findAllWithModels();
        
        var dtos = entities.stream()
                    .map(this::toDto)
                    .collect(Collectors.toList());
        
        return dtos;
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/controller/ModelController.java
package net.sampsoftware.genai.controller;

import lombok.RequiredArgsConstructor;
import net.sampsoftware.genai.dto.ModelDto;
import net.sampsoftware.genai.mapper.ModelMapper;
import net.sampsoftware.genai.model.Model;
import net.sampsoftware.genai.repository.ModelRepository;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/models")
@RequiredArgsConstructor
public class ModelController extends CrudDtoController<Model, ModelDto, Long> {

    private final ModelRepository modelRepository;
    private final ModelMapper modelMapper;

    @Override
    protected JpaRepository<Model, Long> getRepository() {
        return modelRepository;
    }

    @Override
    protected ModelDto toDto(Model entity) {
        return modelMapper.toDto(entity);
    }

    @Override
    protected Model toEntity(ModelDto dto) {
        return modelMapper.toEntity(dto);
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/controller/ModelParameterController.java
package net.sampsoftware.genai.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.dto.ModelParameterDto;
import net.sampsoftware.genai.service.ModelParameterService;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api/model-parameters")
@RequiredArgsConstructor

public class ModelParameterController {

    private final ModelParameterService parameterService;

    @GetMapping("/model/{modelId}")
    public List<ModelParameterDto> getParametersForModel(@PathVariable Long modelId) {
        List<ModelParameterDto> ret = parameterService.getParametersForModel(modelId);
        log.trace(Integer.toString(ret.size()));
        return ret;
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/controller/OperationsController.java
package net.sampsoftware.genai.controller;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.dto.*;
import net.sampsoftware.genai.service.OperationsService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j
@RestController
@RequestMapping("/api/operations")
@RequiredArgsConstructor
public class OperationsController {

    private final OperationsService operationsService;
    private final ObjectMapper objectMapper;

    @PostMapping("/execute")
    public ResponseEntity<OperationResponse> executeOperation(@RequestBody OperationRequest request) {
        log.debug("Executing operation: {} for collection: {}", request.operationId(), request.collectionId());

        try {
            switch (request.operationId()) {
                case "summarize_each":
                    return handleSummarizeEach(request);
                case "summarize_group":
                    return handleSummarizeGroup(request);
                case "generate_relationships":
                    return handleGenerateRelationships(request);
                default:
                    return ResponseEntity.badRequest().body(
                            new OperationResponse(
                                    request.operationId(),
                                    "error",
                                    "Unknown operation: " + request.operationId(),
                                    null
                            )
                    );
            }
        } catch (Exception e) {
            log.error("Error executing operation {}: {}", request.operationId(), e.getMessage(), e);
            return ResponseEntity.internalServerError().body(
                    new OperationResponse(
                            request.operationId(),
                            "error",
                            "Operation failed: " + e.getMessage(),
                            null
                    )
            );
        }
    }

    private ResponseEntity<OperationResponse> handleSummarizeEach(OperationRequest request) {
        if (request.collectionId() == null) {
            return ResponseEntity.badRequest().body(
                    new OperationResponse(request.operationId(), "error", "Collection ID is required", null)
            );
        }

        var result = operationsService.summarizeEachInCollection(
                request.modelConfigurationId(),
                request.collectionId()
        );

        ObjectNode resultNode = objectMapper.createObjectNode();
        resultNode.put("successCount", result.successCount());
        resultNode.put("failureCount", result.failureCount());
        resultNode.set("summaryIds", objectMapper.valueToTree(result.summaryIds()));

        return ResponseEntity.ok(new OperationResponse(
                request.operationId(),
                "success",
                String.format("Successfully created %d summaries", result.successCount()),
                resultNode
        ));
    }

    private ResponseEntity<OperationResponse> handleSummarizeGroup(OperationRequest request) {
        if (request.collectionId() == null) {
            return ResponseEntity.badRequest().body(
                    new OperationResponse(request.operationId(), "error", "Collection ID is required", null)
            );
        }

        var result = operationsService.summarizeCollection(
                request.modelConfigurationId(),
                request.collectionId()
        );

        ObjectNode resultNode = objectMapper.createObjectNode();
        resultNode.put("summaryId", result.summaryId());
        resultNode.put("collectionId", result.collectionId());
        resultNode.put("entityCount", result.entityCount());

        return ResponseEntity.ok(new OperationResponse(
                request.operationId(),
                "success",
                "Successfully created collection summary",
                resultNode
        ));
    }

    private ResponseEntity<OperationResponse> handleGenerateRelationships(OperationRequest request) {
        if (request.collectionId() == null) {
            return ResponseEntity.badRequest().body(
                    new OperationResponse(request.operationId(), "error", "Collection ID is required", null)
            );
        }

        // Extract relationship types from parameters
        var relationshipTypes = java.util.List.of("similar_themes", "influenced_by", "contrasts_with");
        if (request.parameters() != null && request.parameters().has("relationshipTypes")) {
            relationshipTypes = objectMapper.convertValue(
                    request.parameters().get("relationshipTypes"),
                    java.util.List.class
            );
        }

        var result = operationsService.generateRelationships(
                request.modelConfigurationId(),
                request.collectionId(),
                relationshipTypes
        );

        ObjectNode resultNode = objectMapper.createObjectNode();
        resultNode.put("relationshipCount", result.relationshipCount());
        resultNode.set("relationshipIds", objectMapper.valueToTree(result.relationshipIds()));
        resultNode.set("summaryIds", objectMapper.valueToTree(result.summaryIds()));
        resultNode.put("entityPairsProcessed", result.entityPairsProcessed());

        return ResponseEntity.ok(new OperationResponse(
                request.operationId(),
                "success",
                String.format("Successfully generated %d relationships", result.relationshipCount()),
                resultNode
        ));
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/controller/RelationshipController.java
package net.sampsoftware.genai.controller;

import lombok.RequiredArgsConstructor;
import net.sampsoftware.genai.dto.RelationshipRecord;
import net.sampsoftware.genai.model.Relationship;
import net.sampsoftware.genai.service.RelationshipService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/relationships")
@RequiredArgsConstructor
public class RelationshipController {
    private final RelationshipService relationshipService;

    @PostMapping
    public ResponseEntity<RelationshipRecord> createRelationship(@RequestBody RelationshipRecord record) {
        Relationship relationship = fromRecord(record);
        Relationship created = relationshipService.createRelationship(relationship);
        return ResponseEntity.ok(toRecord(created));
    }

    @GetMapping("/item")
    public ResponseEntity<List<RelationshipRecord>> getRelationshipsForItem(
            @RequestParam Long itemId) {
        List<Relationship> relationships = relationshipService.getRelationshipsForItem(itemId);
        List<RelationshipRecord> records = relationships.stream()
                .map(this::toRecord)
                .collect(Collectors.toList());
        return ResponseEntity.ok(records);
    }

    @GetMapping("/type/{relationshipType}")
    public ResponseEntity<List<RelationshipRecord>> getRelationshipsByType(
            @PathVariable String relationshipType) {
        List<Relationship> relationships = relationshipService.getRelationshipsByType(relationshipType);
        List<RelationshipRecord> records = relationships.stream()
                .map(this::toRecord)
                .collect(Collectors.toList());
        return ResponseEntity.ok(records);
    }

    @GetMapping("/type/all")
    public ResponseEntity<List<RelationshipRecord>> getAllRelationships() {
        List<Relationship> relationships = relationshipService.getAllRelationships();
        List<RelationshipRecord> records = relationships.stream()
                .map(this::toRecord)
                .collect(Collectors.toList());
        return ResponseEntity.ok(records);
    }

    private RelationshipRecord toRecord(Relationship relationship) {
        return new RelationshipRecord(
                relationship.getId(),
                relationship.getName(),
                relationship.getRelationshipType(),
                relationship.getSourceItemId(),  // Updated field name
                relationship.getTargetItemId(),  // Updated field name
                relationship.getAttributes(),
                relationship.getCreatedAt(),
                relationship.getUpdatedAt()
        );
    }

    private Relationship fromRecord(RelationshipRecord record) {
        Relationship relationship = new Relationship();
        relationship.setName(record.name());
        relationship.setRelationshipType(record.relationshipType());
        relationship.setSourceItemId(record.sourceItemId());  // Updated field name
        relationship.setTargetItemId(record.targetItemId());  // Updated field name
        relationship.setAttributes(record.attributes());
        return relationship;
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/controller/SummaryController.java
package net.sampsoftware.genai.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.dto.SummaryRecords.DetailedSummaryRecord;
import net.sampsoftware.genai.dto.SummaryRecords.SummaryRecord;
import net.sampsoftware.genai.exception.ResourceNotFoundException;
import net.sampsoftware.genai.model.Summary;
import net.sampsoftware.genai.service.SummaryService;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api/summaries")
@RequiredArgsConstructor
@Validated
public class SummaryController {

    private final SummaryService summaryService;

    /**
     * Get summaries for specific items by ID
     */
    @GetMapping("/items")
    public ResponseEntity<List<DetailedSummaryRecord>> getSummariesForItems(
            @RequestParam List<Long> itemIds
    ) {
        log.debug("Finding summaries for itemIds: {}", itemIds);
        try {
            if (itemIds == null || itemIds.isEmpty()) {
                return ResponseEntity.badRequest().build();
            }

            List<DetailedSummaryRecord> summaries = summaryService.findByItemIds(itemIds);
            return ResponseEntity.ok(summaries);
        } catch (Exception e) {
            log.error("Error fetching summaries for itemIds: {}", itemIds, e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error fetching summaries", e);
        }
    }

    /**
     * Get summaries for a single item
     */
    @GetMapping("/item/{itemId}")
    public ResponseEntity<List<DetailedSummaryRecord>> getSummariesForItem(
            @PathVariable Long itemId
    ) {
        log.debug("Finding summaries for itemId: {}", itemId);
        try {
            List<DetailedSummaryRecord> summaries = summaryService.findByItemIds(List.of(itemId));
            return ResponseEntity.ok(summaries);
        } catch (Exception e) {
            log.error("Error fetching summaries for itemId: {}", itemId, e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error fetching summaries", e);
        }
    }

    /**
     * Get all summaries
     */
    @GetMapping
    public ResponseEntity<List<DetailedSummaryRecord>> getAllSummaries() {
        log.debug("Finding all summaries");
        try {
            List<DetailedSummaryRecord> summaries = summaryService.findAllDetailedSummaryRecords();
            return ResponseEntity.ok(summaries);
        } catch (Exception e) {
            log.error("Error fetching all summaries", e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error fetching summaries", e);
        }
    }

    /**
     * Get summaries by batch ID
     */
    @GetMapping("/batch/{batchId}")
    public ResponseEntity<List<DetailedSummaryRecord>> getSummariesByBatch(
            @PathVariable Long batchId
    ) {
        log.debug("Finding summaries for batchId: {}", batchId);
        try {
            List<DetailedSummaryRecord> summaries = summaryService.findByBatchId(batchId);
            return ResponseEntity.ok(summaries);
        } catch (Exception e) {
            log.error("Error fetching summaries for batchId: {}", batchId, e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error fetching summaries", e);
        }
    }

    /**
     * Get summaries by model configuration
     */
    @GetMapping("/model-config/{modelConfigId}")
    public ResponseEntity<List<DetailedSummaryRecord>> getSummariesByModelConfig(
            @PathVariable Long modelConfigId
    ) {
        log.debug("Finding summaries for modelConfigId: {}", modelConfigId);
        try {
            List<DetailedSummaryRecord> summaries = summaryService.findByModelConfigurationId(modelConfigId);
            return ResponseEntity.ok(summaries);
        } catch (Exception e) {
            log.error("Error fetching summaries for modelConfigId: {}", modelConfigId, e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error fetching summaries", e);
        }
    }

    /**
     * Get summary statistics
     */
    @GetMapping("/stats")
    public ResponseEntity<SummaryStats> getSummaryStats() {
        log.debug("Fetching summary statistics");
        try {
            SummaryStats stats = summaryService.getSummaryStats();
            return ResponseEntity.ok(stats);
        } catch (Exception e) {
            log.error("Error fetching summary statistics", e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error fetching summary statistics", e);
        }
    }

    /**
     * Create a new summary
     */
    @PostMapping
    public ResponseEntity<SummaryRecord> createSummary(@RequestBody @Validated Summary summary) {
        log.debug("Creating new summary for item: {}", summary.getItemId());
        try {
            SummaryRecord created = summaryService.create(summary);
            return ResponseEntity.status(HttpStatus.CREATED).body(created);
        } catch (Exception e) {
            log.error("Error creating summary", e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error creating summary", e);
        }
    }

    /**
     * Update an existing summary
     */
    @PutMapping("/{id}")
    public ResponseEntity<SummaryRecord> updateSummary(@PathVariable Long id, @RequestBody @Validated Summary summary) {
        log.debug("Updating summary with ID: {}", id);
        try {
            summary.setId(id);
            SummaryRecord updated = summaryService.update(summary);
            return ResponseEntity.ok(updated);
        } catch (ResourceNotFoundException e) {
            log.warn("Update Summary not found with ID: {}", id);
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Error updating summary with ID: {}", id, e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error updating summary", e);
        }
    }

    /**
     * Delete a summary
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteSummary(@PathVariable Long id) {
        log.debug("Deleting summary with ID: {}", id);
        try {
            summaryService.delete(id);
            return ResponseEntity.noContent().build();
        } catch (ResourceNotFoundException e) {
            log.warn("Delete Summary not found with ID: {}", id);
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Error deleting summary with ID: {}", id, e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error deleting summary", e);
        }
    }

    // Add these records inside SummaryController class
    public record SummaryStats(
            int totalSummaries,
            int totalItems,
            int totalBatches,
            List<ModelSummaryCount> modelCounts,
            List<BatchSummaryCount> recentBatches
    ) {}

    public record ModelSummaryCount(
            Long modelId,
            String modelName,
            int count
    ) {}

    public record BatchSummaryCount(
            Long batchId,
            int count,
            String createdAt
    ) {}
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/BatchSummaryRequest.java
package net.sampsoftware.genai.dto;

import java.util.List;

public record BatchSummaryRequest(
        Long modelConfigurationId,
        String prompt,
        List<String> itemTypes  // Add itemTypes field
) {}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/BatchSummaryResponse.java
package net.sampsoftware.genai.dto;

import java.util.List;

public record BatchSummaryResponse(
        int successCount,
        int failureCount,
        List<Long> summaryIds,  // Add summaryIds field
        String message          // Add message field
) {}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/ChatRequest.java
package net.sampsoftware.genai.dto;

public class ChatRequest {
    private String content;

    public ChatRequest() {}

    public ChatRequest(String content) {
        this.content = content;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/ChatResponse.java
package net.sampsoftware.genai.dto;

public class ChatResponse {
    private String reply;

    public ChatResponse() {}

    public ChatResponse(String reply) {
        this.reply = reply;
    }

    public String getReply() {
        return reply;
    }

    public void setReply(String reply) {
        this.reply = reply;
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/CytoscapeDto.java
package net.sampsoftware.genai.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class CytoscapeDto {
    private Elements elements;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class Elements {
        private List<CytoscapeNode> nodes;
        private List<CytoscapeEdge> edges;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class CytoscapeNode {
        private NodeData data;
        private String classes;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class NodeData {
        private String id;
        private String label;
        private String type;
        private Object details;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class CytoscapeEdge {
        private EdgeData data;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class EdgeData {
        private String id;
        private String source;
        private String target;
        private String label;
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/EntityReference.java
package net.sampsoftware.genai.dto;

/**
 * A record representing a reference to any entity by its type and ID.
 */
public record EntityReference(
        String entityType,
        Long entityId,
        String name
) {}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/ErrorResponse.java
package net.sampsoftware.genai.dto;

import java.time.Instant;

public record ErrorResponse(
        String error,
        String message,
        String timestamp,
        String path
) {
    public static ErrorResponse of(String error, String message, String path) {
        return new ErrorResponse(error, message,
                Instant.now().toString(), path);
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/GenerateRelationshipsRequest.java
package net.sampsoftware.genai.dto;

import java.util.List;

public record GenerateRelationshipsRequest(
        Long modelConfigurationId,
        Long collectionId,
        List<String> relationshipTypes
) {}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/ModelCallRequest.java
package net.sampsoftware.genai.dto;

public record ModelCallRequest(
    Long modelConfigurationId,
    String prompt
) {}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/ModelCallResponse.java
package net.sampsoftware.genai.dto;

/**
 * DTO for responses from model invocations
 */
public record ModelCallResponse(
    String response
) {}
-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/ModelConfigurationDto.java
package net.sampsoftware.genai.dto;

import com.fasterxml.jackson.databind.JsonNode;
import java.time.Instant;

public record ModelConfigurationDto(
        Long id,
        Long modelId,
        String modelName,
        String modelProvider,
        JsonNode modelConfig,
        String comment,
        Instant createdAt
) {}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/ModelDto.java
package net.sampsoftware.genai.dto;

import lombok.Data;

@Data
public class ModelDto {
    private Long id;
    private String modelName;
    private String modelProvider;
    private String modelApiUrl;
    private String comment;
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/ModelParameterDto.java
package net.sampsoftware.genai.dto;

/**
 * Data Transfer Object for model parameters using Java 17+ record
 */
public record ModelParameterDto(
        Long id,
        Long modelId,
        String paramName,
        String description,
        String dataType,
        String minValue,
        String maxValue,
        String defaultValue,
        Integer displayOrder
) {}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/OperationRequest.java
package net.sampsoftware.genai.dto;

import com.fasterxml.jackson.databind.JsonNode;

public record OperationRequest(
        String operationId,
        Long modelConfigurationId,
        Long collectionId,
        JsonNode parameters
) {}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/OperationResponse.java
package net.sampsoftware.genai.dto;

import com.fasterxml.jackson.databind.JsonNode;

public record OperationResponse(
        String operationId,
        String status,
        String message,
        JsonNode results
) {}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/PersonRecord.java
package net.sampsoftware.genai.dto;

import com.fasterxml.jackson.databind.JsonNode;
import java.time.LocalDate;
import java.time.LocalDateTime;

public record PersonRecord(
        Long id,
        String name,
        String email,
        LocalDate birthDate,
        String occupation,
        JsonNode attributes,
        LocalDateTime createdAt,
        LocalDateTime updatedAt
) {}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/RelationshipRecord.java
package net.sampsoftware.genai.dto;

import com.fasterxml.jackson.databind.JsonNode;
import java.time.LocalDateTime;

public record RelationshipRecord(
        Long id,
        String name,
        String relationshipType,
        Long sourceItemId,      // Changed from sourceType/sourceId
        Long targetItemId,      // Changed from targetType/targetId
        JsonNode attributes,
        LocalDateTime createdAt,
        LocalDateTime updatedAt
) {}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/dto/SummaryRecords.java
package net.sampsoftware.genai.dto;

import java.time.LocalDateTime;
import com.fasterxml.jackson.databind.JsonNode;

public class SummaryRecords {

    public record SummaryRecord(
            Long id,
            Long itemId,           // Changed from entityId
            String content,
            LocalDateTime createdAt
    ) {}

    public record DetailedSummaryRecord(
            Long id,
            Long itemId,           // Changed from entityId
            String itemName,       // Simplified from entityName
            String itemDetails,    // Simplified from entityDetails
            String content,
            String modelName,
            String modelProvider,
            Long modelId,
            Long modelConfigurationId,
            JsonNode modelConfig,
            String configComment,
            LocalDateTime createdAt
    ) {}
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/exception/ResourceNotFoundException.java
package net.sampsoftware.genai.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/GenaiApplication.java
package net.sampsoftware.genai;

import org.springframework.boot.WebApplicationType;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@EnableAsync
public class GenaiApplication {
    public static void main(String[] args) {
        new SpringApplicationBuilder(GenaiApplication.class)
            .web(WebApplicationType.SERVLET) // 🔒 Explicitly use Servlet mode
            .run(args);
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/mapper/ModelConfigurationMapper.java
package net.sampsoftware.genai.mapper;

import net.sampsoftware.genai.dto.ModelConfigurationDto;
import net.sampsoftware.genai.model.Model;
import net.sampsoftware.genai.model.ModelConfiguration;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface ModelConfigurationMapper {

    @Mapping(source = "model.id", target = "modelId")
    @Mapping(source = "model.modelName", target = "modelName")
    @Mapping(source = "model.modelProvider", target = "modelProvider")
    ModelConfigurationDto toDto(ModelConfiguration entity);

    @Mapping(target = "model", source = "modelId", qualifiedByName = "modelFromId")
    @Mapping(target = "createdAt", ignore = true)  // Let entity default it
    ModelConfiguration toEntity(ModelConfigurationDto dto);

    @Named("modelFromId")
    default Model modelFromId(Long id) {
        if (id == null) return null;
        Model model = new Model();
        model.setId(id);
        return model;
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/mapper/ModelMapper.java
package net.sampsoftware.genai.mapper;

import net.sampsoftware.genai.dto.ModelDto;
import net.sampsoftware.genai.model.Model;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface ModelMapper {
    ModelDto toDto(Model entity);
    Model toEntity(ModelDto dto);
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/model/Item.java
package net.sampsoftware.genai.model;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.LocalDateTime;

/**
 * Generic item model that represents any type of item in the system
 * Replaces separate Book, Person, RankedBook, etc. models
 */
@Entity
@Table(name = "items")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Item {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "item_type", nullable = false, length = 100)
    private String itemType;

    @Column(name = "name", nullable = false, length = 500)
    private String name;

    @Column(name = "description", columnDefinition = "text")
    private String description;

    @Column(name = "creator", length = 255)
    private String creator;

    @Column(name = "created_year", length = 10)
    private String createdYear;

    @Column(name = "external_id", length = 255)
    private String externalId;

    @Column(name = "source", length = 255)
    private String source;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "attributes", columnDefinition = "jsonb")
    @Builder.Default
    private JsonNode attributes = JsonNodeFactory.instance.objectNode();

    @Column(name = "created_at", nullable = false, updatable = false)
    @Builder.Default
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(name = "updated_at", nullable = false)
    @Builder.Default
    private LocalDateTime updatedAt = LocalDateTime.now();

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // === CONVENIENCE METHODS FOR COMMON ATTRIBUTES ===

    /**
     * Get a type-safe attribute value
     */
    public <T> T getAttribute(String key, Class<T> type, T defaultValue) {
        try {
            if (attributes == null || !attributes.has(key)) {
                return defaultValue;
            }
            JsonNode node = attributes.get(key);
            if (node.isNull()) {
                return defaultValue;
            }

            // Handle different types
            if (type == String.class) {
                return type.cast(node.asText());
            } else if (type == Integer.class) {
                return type.cast(node.asInt());
            } else if (type == Long.class) {
                return type.cast(node.asLong());
            } else if (type == Double.class) {
                return type.cast(node.asDouble());
            } else if (type == Boolean.class) {
                return type.cast(node.asBoolean());
            }

            return defaultValue;
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * Set an attribute value
     */
    public void setAttribute(String key, Object value) {
        if (attributes == null) {
            attributes = JsonNodeFactory.instance.objectNode();
        }

        if (attributes.isObject()) {
            com.fasterxml.jackson.databind.node.ObjectNode objectNode =
                    (com.fasterxml.jackson.databind.node.ObjectNode) attributes;

            if (value == null) {
                objectNode.putNull(key);
            } else if (value instanceof String) {
                objectNode.put(key, (String) value);
            } else if (value instanceof Integer) {
                objectNode.put(key, (Integer) value);
            } else if (value instanceof Long) {
                objectNode.put(key, (Long) value);
            } else if (value instanceof Double) {
                objectNode.put(key, (Double) value);
            } else if (value instanceof Boolean) {
                objectNode.put(key, (Boolean) value);
            } else {
                objectNode.put(key, value.toString());
            }
        }
    }

    // === ITEM TYPE SPECIFIC CONVENIENCE METHODS ===

    /**
     * For book items - get rank
     */
    public Integer getRank() {
        return getAttribute("rank", Integer.class, null);
    }

    public void setRank(Integer rank) {
        setAttribute("rank", rank);
    }

    /**
     * For book items - get ISBN
     */
    public String getIsbn() {
        return getAttribute("isbn", String.class, null);
    }

    public void setIsbn(String isbn) {
        setAttribute("isbn", isbn);
    }

    /**
     * For person items - get email
     */
    public String getEmail() {
        return getAttribute("email", String.class, null);
    }

    public void setEmail(String email) {
        setAttribute("email", email);
    }

    /**
     * For person items - get occupation
     */
    public String getOccupation() {
        return getAttribute("occupation", String.class, null);
    }

    public void setOccupation(String occupation) {
        setAttribute("occupation", occupation);
    }

    /**
     * For movie items - get IMDB ID
     */
    public String getImdbId() {
        return getAttribute("imdb_id", String.class, null);
    }

    public void setImdbId(String imdbId) {
        setAttribute("imdb_id", imdbId);
    }

    /**
     * For movie items - get director
     */
    public String getDirector() {
        return getCreator(); // Director is stored in creator field
    }

    public void setDirector(String director) {
        setCreator(director);
    }

    /**
     * For academic paper items - get DOI
     */
    public String getDoi() {
        return getAttribute("doi", String.class, null);
    }

    public void setDoi(String doi) {
        setAttribute("doi", doi);
    }

    /**
     * For academic paper items - get journal
     */
    public String getJournal() {
        return getAttribute("journal", String.class, null);
    }

    public void setJournal(String journal) {
        setAttribute("journal", journal);
    }

    // === DISPLAY HELPERS ===

    /**
     * Get a human-readable display name
     */
    public String getDisplayName() {
        if (name == null || name.trim().isEmpty()) {
            return String.format("%s #%d", capitalizeItemType(itemType), id);
        }
        return name;
    }

    /**
     * Get item details for display
     */
    public String getDisplayDetails() {
        StringBuilder details = new StringBuilder();

        if (creator != null && !creator.trim().isEmpty()) {
            details.append("By: ").append(creator);
        }

        if (createdYear != null && !createdYear.trim().isEmpty()) {
            if (details.length() > 0) details.append(", ");
            details.append("Year: ").append(createdYear);
        }

        // Add type-specific details
        switch (itemType.toLowerCase()) {
            case "book":
            case "ranked_book":
                Integer rank = getRank();
                if (rank != null) {
                    if (details.length() > 0) details.append(", ");
                    details.append("Rank: ").append(rank);
                }
                break;

            case "person":
                String occupation = getOccupation();
                if (occupation != null) {
                    if (details.length() > 0) details.append(", ");
                    details.append("Occupation: ").append(occupation);
                }
                break;

            case "movie":
                String imdbId = getImdbId();
                if (imdbId != null) {
                    if (details.length() > 0) details.append(", ");
                    details.append("IMDB: ").append(imdbId);
                }
                break;
        }

        return details.length() > 0 ? details.toString() : null;
    }

    private String capitalizeItemType(String itemType) {
        if (itemType == null || itemType.isEmpty()) return "Item";

        String[] parts = itemType.toLowerCase().split("[_\\s]+");
        StringBuilder result = new StringBuilder();

        for (String part : parts) {
            if (result.length() > 0) result.append(" ");
            result.append(part.substring(0, 1).toUpperCase())
                    .append(part.substring(1));
        }

        return result.toString();
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/model/Message.java
package net.sampsoftware.genai.model;

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Table(name = "messages")
@EntityListeners(AuditingEntityListener.class)
public class Message {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String content;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdDate;

    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }

    public LocalDateTime getCreatedDate() { return createdDate; }
    public void setCreatedDate(LocalDateTime createdDate) { this.createdDate = createdDate; }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/model/Model.java
package net.sampsoftware.genai.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(
        name = "model",
        uniqueConstraints = {
                @UniqueConstraint(
                        name = "model_name_provider_unique",
                        columnNames = {"modelName", "modelProvider"}
                )
        }
)
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Model {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "model_name", nullable = false, length = 200)
    private String modelName;

    @Column(name = "model_provider", nullable = false, length = 200)
    private String modelProvider;

    @Column(name = "model_api_url", length = 500)  // Increased from 200 to 500
    private String modelApiUrl;

    @Column(name = "comment", columnDefinition = "text")
    private String comment;
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/model/ModelCall.java
package net.sampsoftware.genai.model;

import com.fasterxml.jackson.databind.JsonNode;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.Instant;

@Entity
@Table(name = "model_calls")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ModelCall {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "model_configuration_id")
    private ModelConfiguration modelConfiguration;

    /**
     * Snapshot of model configuration at execution time
     */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "model_configuration_json", columnDefinition = "jsonb")
    private JsonNode modelConfigurationJson;

    @Column(name = "provider")
    private String provider;

    /**
     * Human-readable prompt text combining system, user, and other prompt components
     */
    @Column(name = "prompt_text", columnDefinition = "text")
    private String promptText;

    /**
     * Complete prompt structure including all Spring AI Prompt object data
     */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "prompt_json", columnDefinition = "jsonb")
    private JsonNode promptJson;

    /**
     * Raw response content as returned by the model
     */
    @Column(name = "response_text", columnDefinition = "text")
    private String responseText;

    /**
     * Complete ChatResponse object data including metadata
     */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "response_json", columnDefinition = "jsonb")
    private JsonNode responseJson;

    /**
     * Token usage statistics from the response
     */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "token_usage", columnDefinition = "jsonb")
    private JsonNode tokenUsage;

    /**
     * Complete ChatOptions object including all provider-specific options
     */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "chat_options", columnDefinition = "jsonb")
    private JsonNode chatOptions;

    /**
     * Additional metadata from the request/response cycle
     */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "metadata", columnDefinition = "jsonb")
    private JsonNode metadata;

    // Changed: Now has NOT NULL DEFAULT false in schema
    @Builder.Default
    @Column(name = "success", nullable = false)
    private Boolean success = false;

    @Column(name = "error_message", columnDefinition = "text")
    private String errorMessage;

    @Column(name = "error_class")
    private String errorClass;

    /**
     * Stack trace for debugging failures
     */
    @Column(name = "error_stacktrace", columnDefinition = "text")
    private String errorStacktrace;

    @Column(name = "start_time")
    private Instant startTime;

    @Column(name = "end_time")
    private Instant endTime;

    @Column(name = "duration_ms")
    private Long durationMs;

    @Column(name = "api_duration_ms")
    private Long apiDurationMs;

    @Column(name = "processing_duration_ms")
    private Long processingDurationMs;

    @Column(name = "batch_id")
    private Long batchId;

    // Changed: Now NOT NULL in schema, so ensure it's always set
    @Builder.Default
    @Column(name = "created_at", nullable = false)
    private Instant createdAt = Instant.now();

    /**
     * Model name at time of execution (denormalized for easier querying)
     */
    @Column(name = "model_name")
    private String modelName;

    /**
     * Model provider at time of execution (denormalized for easier querying)
     */
    @Column(name = "model_provider")
    private String modelProvider;

    /**
     * Request correlation ID for tracing across services
     */
    @Column(name = "correlation_id")
    private String correlationId;

    /**
     * User/session identifier if available
     */
    @Column(name = "user_id")
    private String userId;

    /**
     * Request source/context (e.g., "batch_summary", "chat", "operations")
     */
    @Column(name = "request_context")
    private String requestContext;
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/model/ModelConfiguration.java
package net.sampsoftware.genai.model;

import com.fasterxml.jackson.databind.JsonNode;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.Instant;

@Entity
@Table(name = "model_configuration")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ModelConfiguration {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "model_id")
    private Model model;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(columnDefinition = "jsonb")
    private JsonNode modelConfig;

    private String comment;

    @Builder.Default
    private Instant createdAt = Instant.now();
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/model/ModelParameter.java
package net.sampsoftware.genai.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "model_parameter")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ModelParameter {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "model_id")
    private Model model;
    
    private String paramName;
    private String description;
    private String dataType; // e.g., "number", "string"
    private String minValue;
    private String maxValue;
    private String defaultValue;
    private Integer displayOrder;
}
-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/model/Relationship.java
package net.sampsoftware.genai.model;

import com.fasterxml.jackson.databind.JsonNode;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.DynamicUpdate;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.LocalDateTime;

@Entity
@Table(name = "relationships")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@DynamicUpdate
public class Relationship {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "relationship_type", nullable = false)
    private String relationshipType;

    /**
     * Source Item ID - everything is now an Item
     */
    @Column(name = "source_item_id", nullable = false)
    private Long sourceItemId;

    /**
     * Target Item ID - everything is now an Item
     */
    @Column(name = "target_item_id", nullable = false)
    private Long targetItemId;

    /**
     * Optional name/description of this relationship
     */
    @Column(name = "name")
    private String name;

    /**
     * JSONB for relationship-specific attributes
     * Can store strength, confidence, metadata, etc.
     */
    @Column(columnDefinition = "jsonb")
    @JdbcTypeCode(SqlTypes.JSON)
    private JsonNode attributes;

    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // Utility methods

    /**
     * Check if this relationship has attributes
     */
    public boolean hasAttributes() {
        return attributes != null && !attributes.isNull() && attributes.size() > 0;
    }

    /**
     * Get an attribute field value
     */
    public String getAttributeField(String field) {
        if (attributes == null || !attributes.has(field)) {
            return null;
        }
        return attributes.get(field).asText();
    }

    /**
     * Get numeric attribute value
     */
    public Double getNumericAttribute(String field) {
        if (attributes == null || !attributes.has(field)) {
            return null;
        }
        return attributes.get(field).asDouble();
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/model/Summary.java
package net.sampsoftware.genai.model;

import com.fasterxml.jackson.databind.JsonNode;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.DynamicUpdate;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.LocalDateTime;

@Entity
@Table(name = "summaries")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@DynamicUpdate
public class Summary {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "model_configuration_id")
    private ModelConfiguration modelConfiguration;

    @Column(name = "item_id", nullable = false)
    private Long itemId;

    @Column(name = "content", columnDefinition = "text")
    private String content;

    @Column(name = "batch_id")
    private Long batchId;

    @Column(columnDefinition = "jsonb")
    @JdbcTypeCode(SqlTypes.JSON)
    private JsonNode metadata;

    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // Utility methods
    public Long getModelConfigurationId() {
        return modelConfiguration != null ? modelConfiguration.getId() : null;
    }

    /**
     * Check if this summary has metadata
     */
    public boolean hasMetadata() {
        return metadata != null && !metadata.isNull() && metadata.size() > 0;
    }

    /**
     * Get a metadata field value
     */
    public String getMetadataField(String field) {
        if (metadata == null || !metadata.has(field)) {
            return null;
        }
        return metadata.get(field).asText();
    }

}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/repository/ItemRepository.java
package net.sampsoftware.genai.repository;

import net.sampsoftware.genai.model.Item;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository for the item model
 * Replaces separate BookRepository, PersonRepository, etc.
 */
@Repository
public interface ItemRepository extends JpaRepository<Item, Long> {
    List<Item> findByItemType(String itemType);
    List<Item> findByItemTypeOrderByName(String itemType);
    List<Item> findByItemTypeAndNameContainingIgnoreCase(String itemType, String name);
    Optional<Item> findByItemTypeAndExternalId(String itemType, String externalId);
    List<Item> findByCreator(String creator);
    List<Item> findByCreatorContainingIgnoreCase(String creator);
    List<Item> findByCreatedYear(String createdYear);
    List<Item> findBySource(String source);
    List<Item> findByItemTypeIn(List<String> itemTypes);
    List<String> findDistinctItemTypes();

    // === JSONB ATTRIBUTE QUERIES ===

    @Query("SELECT i FROM Item i WHERE i.itemType = :itemType AND " +
            "JSON_EXTRACT(i.attributes, '$.rank') = :rank")
    List<Item> findByItemTypeAndRank(@Param("itemType") String itemType,
                                     @Param("rank") Integer rank);

    @Query("SELECT i FROM Item i WHERE i.itemType = :itemType AND " +
            "JSON_EXTRACT(i.attributes, '$.isbn') = :isbn")
    Optional<Item> findByItemTypeAndIsbn(@Param("itemType") String itemType,
                                         @Param("isbn") String isbn);

    @Query("SELECT i FROM Item i WHERE i.itemType = :itemType AND " +
            "JSON_EXTRACT(i.attributes, '$.email') = :email")
    Optional<Item> findByItemTypeAndEmail(@Param("itemType") String itemType,
                                          @Param("email") String email);

    @Query("SELECT i FROM Item i WHERE i.itemType = :itemType AND " +
            "JSON_EXTRACT(i.attributes, '$.doi') = :doi")
    Optional<Item> findByItemTypeAndDoi(@Param("itemType") String itemType,
                                        @Param("doi") String doi);

    @Query("SELECT i FROM Item i WHERE i.itemType = :itemType AND " +
            "JSON_EXTRACT(i.attributes, '$.imdb_id') = :imdbId")
    Optional<Item> findByItemTypeAndImdbId(@Param("itemType") String itemType,
                                           @Param("imdbId") String imdbId);


    default List<Item> findAllBooks() {
        return findByItemType("book");
    }

    default List<Item> findAllRankedBooks() {
        return findByItemType("ranked_book");
    }

    default List<Item> findAllPeople() {
        return findByItemType("person");
    }

    default List<Item> findAllMovies() {
        return findByItemType("movie");
    }

    default List<Item> findAllPapers() {
        return findByItemType("academic_paper");
    }

    default List<Item> findBooksByAuthor(String author) {
        return findByItemTypeAndCreator("book", author);
    }

    default List<Item> findMoviesByDirector(String director) {
        return findByItemTypeAndCreator("movie", director);
    }

    // === ADVANCED QUERIES ===

    @Query("SELECT DISTINCT i.itemType FROM Item i ORDER BY i.itemType")
    List<String> findAllItemTypes();

    @Query("SELECT DISTINCT i.creator FROM Item i WHERE i.creator IS NOT NULL ORDER BY i.creator")
    List<String> findAllCreators();

    @Query("SELECT DISTINCT i.createdYear FROM Item i WHERE i.createdYear IS NOT NULL ORDER BY i.createdYear")
    List<String> findAllCreatedYears();

    @Query("SELECT COUNT(i) FROM Item i WHERE i.itemType = :itemType")
    Long countByItemType(@Param("itemType") String itemType);

    // === SEARCH METHODS ===

    @Query("SELECT i FROM Item i WHERE " +
            "(:itemType IS NULL OR i.itemType = :itemType) AND " +
            "(:searchTerm IS NULL OR " +
            " LOWER(i.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
            " LOWER(i.creator) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
            " LOWER(i.description) LIKE LOWER(CONCAT('%', :searchTerm, '%')))")
    List<Item> searchItems(@Param("itemType") String itemType,
                           @Param("searchTerm") String searchTerm);

    // === BULK OPERATIONS ===

    @Query("DELETE FROM Item i WHERE i.itemType = :itemType")
    void deleteAllByItemType(@Param("itemType") String itemType);

    // === HELPER METHOD IMPLEMENTATIONS ===

    default List<Item> findByItemTypeAndCreator(String itemType, String creator) {
        return findByItemType(itemType).stream()
                .filter(i -> creator.equals(i.getCreator()))
                .toList();
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/repository/MessageRepository.java
package net.sampsoftware.genai.repository;

import net.sampsoftware.genai.model.Message;
import org.springframework.data.jpa.repository.JpaRepository;

public interface MessageRepository extends JpaRepository<Message, Long> {}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/repository/ModelCallRepository.java
package net.sampsoftware.genai.repository;

import net.sampsoftware.genai.model.ModelCall;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.List;

@Repository
public interface ModelCallRepository extends JpaRepository<ModelCall, Long> {

    List<ModelCall> findByModelConfigurationIdOrderByCreatedAtDesc(Long modelConfigurationId);

    List<ModelCall> findByBatchIdOrderByCreatedAtDesc(Long batchId);

    List<ModelCall> findBySuccessOrderByCreatedAtDesc(Boolean success);

    List<ModelCall> findByProviderOrderByCreatedAtDesc(String provider);

    @Query("SELECT mc FROM ModelCall mc WHERE mc.createdAt BETWEEN :start AND :end ORDER BY mc.createdAt DESC")
    List<ModelCall> findByDateRange(@Param("start") Instant start, @Param("end") Instant end);

    @Query("SELECT AVG(mc.durationMs) FROM ModelCall mc WHERE mc.success = true AND mc.modelConfiguration.id = :configId")
    Double getAverageDurationByModelConfig(@Param("configId") Long configId);

    @Query("SELECT AVG(mc.durationMs) FROM ModelCall mc WHERE mc.success = true AND mc.provider = :provider")
    Double getAverageDurationByProvider(@Param("provider") String provider);

    @Query("SELECT COUNT(mc) FROM ModelCall mc WHERE mc.provider = :provider AND mc.success = :success")
    Long countByProviderAndSuccess(@Param("provider") String provider, @Param("success") Boolean success);
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/repository/ModelConfigurationRepository.java
package net.sampsoftware.genai.repository;

import net.sampsoftware.genai.model.ModelConfiguration;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface ModelConfigurationRepository extends JpaRepository<ModelConfiguration, Long> {

    @Query("SELECT c FROM ModelConfiguration c JOIN FETCH c.model WHERE c.id = :id")
    Optional<ModelConfiguration> findByIdWithModel(@Param("id") Long id);

    @Query("SELECT c FROM ModelConfiguration c JOIN FETCH c.model")
    List<ModelConfiguration> findAllWithModels();


}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/repository/ModelParameterRepository.java
package net.sampsoftware.genai.repository;

import net.sampsoftware.genai.model.ModelParameter;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ModelParameterRepository extends JpaRepository<ModelParameter, Long> {
    
    /**
     * Find parameters for a specific model, ordered by display order
     */
    List<ModelParameter> findByModelIdOrderByDisplayOrder(Long modelId);
}
-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/repository/ModelRepository.java
package net.sampsoftware.genai.repository;

import net.sampsoftware.genai.model.Model;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface ModelRepository extends JpaRepository<Model, Long> {
    Optional<Model> findByModelNameAndModelProvider(String modelName, String modelProvider);
    boolean existsByModelNameAndModelProvider(String modelName, String modelProvider);

}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/repository/RelationshipRepository.java
package net.sampsoftware.genai.repository;

import net.sampsoftware.genai.model.Relationship;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface RelationshipRepository extends JpaRepository<Relationship, Long> {
    List<Relationship> findByRelationshipType(String relationshipType);

    List<Relationship> findBySourceTypeAndSourceId(String sourceType, Long sourceId);

    List<Relationship> findByTargetTypeAndTargetId(String targetType, Long targetId);

    @Query("SELECT r FROM Relationship r WHERE " +
            "(r.sourceType = :entityType AND r.sourceId = :entityId) OR " +
            "(r.targetType = :entityType AND r.targetId = :entityId)")
    List<Relationship> findByEntity(@Param("entityType") String entityType,
                                    @Param("entityId") Long entityId);

    List<Relationship> findByTargetTypeAndTargetIdAndRelationshipType(
            String targetType,
            Long targetId,
            String relationshipType
    );

    List<Relationship> findBySourceTypeAndSourceIdAndRelationshipType(
            String sourceType,
            Long sourceId,
            String relationshipType
    );

    @Query("SELECT r FROM Relationship r WHERE " +
            "r.relationshipType = :relationshipType AND " +
            "r.sourceType = :sourceType AND " +
            "r.targetType = :targetType")
    List<Relationship> findByRelationshipTypeAndSourceTypeAndTargetType(
            @Param("relationshipType") String relationshipType,
            @Param("sourceType") String sourceType,
            @Param("targetType") String targetType
    );

    @Query("SELECT r FROM Relationship r WHERE " +
            "r.targetType = 'collection' AND " +
            "r.targetId = :collectionId AND " +
            "r.relationshipType = 'collection'")
    List<Relationship> findCollectionMembers(@Param("collectionId") Long collectionId);

    @Query("SELECT r FROM Relationship r WHERE " +
            "r.targetType = 'collection' AND " +
            "r.targetId = :collectionId AND " +
            "r.relationshipType = 'collection_definition'")
    List<Relationship> findCollectionDefinition(@Param("collectionId") Long collectionId);
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/repository/SummaryRepository.java
package net.sampsoftware.genai.repository;

import net.sampsoftware.genai.model.Summary;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface SummaryRepository extends JpaRepository<Summary, Long> {

    List<Summary> findByItemIdIn(List<Long> itemIds);

    List<Summary> findByItemId(Long itemId);

    List<Summary> findByItemIdOrderByCreatedAtDesc(Long itemId);

    List<Summary> findByBatchId(Long batchId);

    List<Summary> findByBatchIdOrderByCreatedAtDesc(Long batchId);

    List<Summary> findByBatchIdIsNull();

    List<Summary> findByModelConfigurationId(Long modelConfigurationId);

    List<Summary> findByModelConfigurationIdOrderByCreatedAtDesc(Long modelConfigurationId);

    @Query("SELECT s FROM Summary s " +
            "JOIN FETCH s.modelConfiguration mc " +
            "JOIN FETCH mc.model " +
            "WHERE s.id = :id")
    Optional<Summary> findByIdWithDetails(@Param("id") Long id);

    @Query("SELECT s FROM Summary s " +
            "JOIN FETCH s.modelConfiguration mc " +
            "JOIN FETCH mc.model " +
            "ORDER BY s.createdAt DESC")
    List<Summary> findAllWithDetails();

    @Query("SELECT s FROM Summary s " +
            "JOIN FETCH s.modelConfiguration mc " +
            "JOIN FETCH mc.model " +
            "WHERE s.itemId IN :itemIds " +
            "ORDER BY s.createdAt DESC")
    List<Summary> findByItemIdInWithDetails(@Param("itemIds") List<Long> itemIds);

    @Query("SELECT s FROM Summary s " +
            "JOIN FETCH s.modelConfiguration mc " +
            "JOIN FETCH mc.model " +
            "WHERE s.batchId = :batchId " +
            "ORDER BY s.createdAt DESC")
    List<Summary> findByBatchIdWithDetails(@Param("batchId") Long batchId);

    /**
     * Count distinct items that have summaries
     */
    @Query("SELECT COUNT(DISTINCT s.itemId) FROM Summary s")
    long countDistinctItems();

    /**
     * Count distinct batches
     */
    @Query("SELECT COUNT(DISTINCT s.batchId) FROM Summary s WHERE s.batchId IS NOT NULL")
    long countDistinctBatches();

    /**
     * Count summaries by model (for analytics)
     */
    @Query("SELECT mc.model.id, mc.model.modelName, mc.model.modelProvider, COUNT(s) " +
            "FROM Summary s JOIN s.modelConfiguration mc " +
            "GROUP BY mc.model.id, mc.model.modelName, mc.model.modelProvider " +
            "ORDER BY COUNT(s) DESC")
    List<Object[]> countSummariesByModel();

    /**
     * Count summaries by model configuration
     */
    @Query("SELECT mc.id, mc.comment, COUNT(s) " +
            "FROM Summary s JOIN s.modelConfiguration mc " +
            "GROUP BY mc.id, mc.comment " +
            "ORDER BY COUNT(s) DESC")
    List<Object[]> countSummariesByModelConfiguration();

    /**
     * Get recent batch statistics
     */
    @Query("SELECT s.batchId, COUNT(s), MIN(s.createdAt), MAX(s.createdAt) " +
            "FROM Summary s WHERE s.batchId IS NOT NULL " +
            "GROUP BY s.batchId " +
            "ORDER BY MAX(s.createdAt) DESC")
    List<Object[]> getRecentBatchCounts(Pageable pageable);

    /**
     * Convenience method for recent batch stats
     */
    default List<Object[]> getRecentBatchCounts(int limit) {
        return getRecentBatchCounts(PageRequest.of(0, limit));
    }

    /**
     * Count summaries by item type (requires join with Item table)
     */
    @Query("SELECT i.itemType, COUNT(s) " +
            "FROM Summary s JOIN Item i ON i.id = s.itemId " +
            "GROUP BY i.itemType " +
            "ORDER BY COUNT(s) DESC")
    List<Object[]> countSummariesByItemType();

    /**
     * Get summary length statistics
     */
    @Query("SELECT AVG(LENGTH(s.content)), MIN(LENGTH(s.content)), MAX(LENGTH(s.content)) " +
            "FROM Summary s")
    Object[] getSummaryLengthStats();

    /**
     * Count summaries created in the last N days
     */
    @Query("SELECT COUNT(s) FROM Summary s WHERE s.createdAt >= :date")
    long countSummariesSince(@Param("date") LocalDateTime date);

    /**
     * Convenience method for recent summary count
     */
    default long countSummariesInLastDays(int days) {
        return countSummariesSince(LocalDateTime.now().minusDays(days));
    }

    // === ADVANCED QUERIES ===

    /**
     * Find summaries with content containing specific text
     */
    @Query("SELECT s FROM Summary s WHERE LOWER(s.content) LIKE LOWER(CONCAT('%', :searchTerm, '%'))")
    List<Summary> findByContentContaining(@Param("searchTerm") String searchTerm);

    /**
     * Find summaries with specific metadata attributes
     */
    @Query("SELECT s FROM Summary s WHERE s.metadata IS NOT NULL")
    List<Summary> findSummariesWithMetadata();

    /**
     * Find summaries without metadata
     */
    @Query("SELECT s FROM Summary s WHERE s.metadata IS NULL")
    List<Summary> findSummariesWithoutMetadata();

    /**
     * Find summaries by content length range
     */
    @Query("SELECT s FROM Summary s WHERE LENGTH(s.content) BETWEEN :minLength AND :maxLength")
    List<Summary> findByContentLength(@Param("minLength") int minLength, @Param("maxLength") int maxLength);

    /**
     * Find items with multiple summaries (useful for analysis)
     */
    @Query("SELECT s.itemId, COUNT(s) FROM Summary s " +
            "GROUP BY s.itemId HAVING COUNT(s) > 1 " +
            "ORDER BY COUNT(s) DESC")
    List<Object[]> findItemsWithMultipleSummaries();

    /**
     * Find batches with failed summaries (if you track failures)
     */
    @Query("SELECT s.batchId, COUNT(s) FROM Summary s " +
            "WHERE s.batchId IS NOT NULL " +
            "GROUP BY s.batchId " +
            "HAVING COUNT(s) < :expectedCount")
    List<Object[]> findIncompleteBatches(@Param("expectedCount") long expectedCount);

    // === MAINTENANCE QUERIES ===

    /**
     * Find summaries that might need updates (business logic dependent)
     */
    @Query("SELECT s FROM Summary s " +
            "WHERE s.createdAt < :cutoffDate " +
            "AND s.modelConfiguration.id IN :outdatedModelConfigs")
    List<Summary> findSummariesNeedingUpdate(
            @Param("cutoffDate") LocalDateTime cutoffDate,
            @Param("outdatedModelConfigs") List<Long> outdatedModelConfigs
    );

    /**
     * Delete summaries older than specified date
     */
    @Query("DELETE FROM Summary s WHERE s.createdAt < :cutoffDate")
    int deleteOldSummaries(@Param("cutoffDate") LocalDateTime cutoffDate);

    /**
     * Delete summaries for specific items
     */
    int deleteByItemIdIn(List<Long> itemIds);

    /**
     * Delete summaries from specific batch
     */
    int deleteByBatchId(Long batchId);
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/service/AIService.java
// backend/src/main/java/net/sampsoftware/genai/service/AIService.java
package net.sampsoftware.genai.service;

import com.fasterxml.jackson.databind.JsonNode;
import lombok.RequiredArgsConstructor;
import net.sampsoftware.genai.model.ModelConfiguration;
import org.springframework.ai.openai.OpenAiChatModel;
import org.springframework.ai.openai.OpenAiChatOptions;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.messages.SystemMessage;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AIService extends BaseAiApiService {

    private final OpenAiChatModel chatModel;

    public String generateResponse(String promptText, ModelConfiguration modelConfig) {
        OpenAiChatOptions options = buildChatOptions(modelConfig);

        return executeApiCall(() -> {
            UserMessage userMessage = new UserMessage(promptText);
            Prompt prompt = new Prompt(userMessage, options);
            return chatModel.call(prompt).getResult().getOutput().getText();
        });
    }

    public String generateResponse(String systemPrompt, String userPrompt,
                                   ModelConfiguration modelConfig) {
        OpenAiChatOptions options = buildChatOptions(modelConfig);

        return executeApiCall(() -> {
            SystemMessage systemMessage = new SystemMessage(systemPrompt);
            UserMessage userMessage = new UserMessage(userPrompt);
            Prompt prompt = new Prompt(java.util.List.of(systemMessage, userMessage), options);
            return chatModel.call(prompt).getResult().getOutput().getText();
        });
    }

    private OpenAiChatOptions buildChatOptions(ModelConfiguration modelConfig) {
        if (modelConfig == null || modelConfig.getModelConfig() == null) {
            return OpenAiChatOptions.builder().build();
        }

        JsonNode configNode = modelConfig.getModelConfig();

        OpenAiChatOptions.Builder optionsBuilder = OpenAiChatOptions.builder();

        if (configNode.has("temperature")) {
            optionsBuilder.temperature(configNode.get("temperature").doubleValue());
        }

        if (configNode.has("top_p")) {
            optionsBuilder.topP(configNode.get("top_p").doubleValue());
        }

        if (configNode.has("max_tokens")) {
            optionsBuilder.maxTokens(configNode.get("max_tokens").intValue());
        }

        if (configNode.has("frequency_penalty")) {
            optionsBuilder.frequencyPenalty(configNode.get("frequency_penalty").doubleValue());
        }

        if (configNode.has("presence_penalty")) {
            optionsBuilder.presencePenalty(configNode.get("presence_penalty").doubleValue());
        }

        return optionsBuilder.build();
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/service/AsyncItemProcessor.java
package net.sampsoftware.genai.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.model.Item;
import net.sampsoftware.genai.model.ModelConfiguration;
import net.sampsoftware.genai.model.Summary;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.util.concurrent.CompletableFuture;

@Slf4j
@Service
@RequiredArgsConstructor
public class AsyncItemProcessor {

    private final AIService aiService;
    private final SummaryService summaryService;
    private final ObjectMapper objectMapper;

    /**
     * Result of processing an item
     */
    public record ProcessingResult(
            boolean success,
            Long itemId,
            Long summaryId,
            String error
    ) {}

    @Async
    public CompletableFuture<ProcessingResult> processItemAsync(
            Item item,
            String systemPrompt,
            ModelConfiguration modelConfiguration,
            Long batchId
    ) {
        try {
            log.debug("Processing item {} (type: {}) in batch {}",
                    item.getId(), item.getItemType(), batchId);

            // Build item info as JSON for the AI
            String itemInfo = buildItemInfo(item);

            // Generate summary using AI
            String summaryText = aiService.generateResponse(
                    systemPrompt,
                    itemInfo,
                    modelConfiguration
            );

            log.debug("Generated summary for item {} (length: {})",
                    item.getId(), summaryText.length());

            // Create and save summary
            Summary summary = Summary.builder()
                    .modelConfiguration(modelConfiguration)
                    .itemId(item.getId())
                    .content(summaryText)
                    .batchId(batchId)
                    .build();

            Summary savedSummary = summaryService.save(summary);

            log.debug("Saved summary {} for item {} in batch {}",
                    savedSummary.getId(), item.getId(), batchId);

            return CompletableFuture.completedFuture(
                    new ProcessingResult(true, item.getId(), savedSummary.getId(), null)
            );

        } catch (Exception e) {
            log.error("Error processing item {} in batch {}: {}",
                    item.getId(), batchId, e.getMessage(), e);

            return CompletableFuture.completedFuture(
                    new ProcessingResult(false, item.getId(), null, e.getMessage())
            );
        }
    }

    /**
     * Build structured item information for AI processing
     */
    private String buildItemInfo(Item item) {
        try {
            // Create a structured representation of the item
            var itemData = objectMapper.createObjectNode();

            itemData.put("id", item.getId());
            itemData.put("name", item.getName());
            itemData.put("type", item.getItemType());

            // Add attributes if present
            if (item.getAttributes() != null) {
                itemData.set("attributes", item.getAttributes());
            }

            // Format as readable JSON
            return objectMapper.writerWithDefaultPrettyPrinter()
                    .writeValueAsString(itemData);

        } catch (Exception e) {
            log.warn("Error building JSON for item {}, falling back to simple format: {}",
                    item.getId(), e.getMessage());

            // Fallback to simple string format
            return String.format("""
                Item Details:
                - ID: %d
                - Name: %s  
                - Type: %s
                - Attributes: %s
                """,
                    item.getId(),
                    item.getName(),
                    item.getItemType(),
                    item.getAttributes() != null ? item.getAttributes().toString() : "none"
            );
        }
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/service/AsyncItemSummaryService.java
package net.sampsoftware.genai.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.dto.BatchSummaryResponse;
import net.sampsoftware.genai.model.Item;
import net.sampsoftware.genai.model.ModelConfiguration;
import net.sampsoftware.genai.model.Summary;
import net.sampsoftware.genai.repository.ItemRepository;
import net.sampsoftware.genai.repository.RelationshipRepository;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class AsyncItemSummaryService {

    private final AIService aiService;
    private final ModelService modelService;
    private final ItemRepository itemRepository;
    private final RelationshipRepository relationshipRepository;
    private final AsyncItemProcessor asyncItemProcessor;

    /**
     * Generate summaries for all items, optionally filtered by type
     */
    public BatchSummaryResponse generateSummariesForAllItems(
            String prompt,
            Long modelConfigurationId,
            List<String> itemTypes
    ) {
        Long batchId = System.nanoTime();

        log.debug("Processing all items with batch ID {}, types: {}", batchId, itemTypes);

        // Get items, filtered by type if specified
        List<Item> items = (itemTypes == null || itemTypes.isEmpty())
            ? itemRepository.findAll()
            : itemRepository.findByItemTypeIn(itemTypes);

        return processItems(items, prompt, modelConfigurationId, batchId);
    }

    /**
     * Generate summaries for specific items by ID
     */
    public BatchSummaryResponse generateSummariesForItems(
            List<Long> itemIds,
            String prompt,
            Long modelConfigurationId
    ) {
        Long batchId = System.nanoTime();

        log.debug("Processing {} specific items with batch ID {}", itemIds.size(), batchId);

        List<Item> items = itemRepository.findAllById(itemIds);

        if (items.size() != itemIds.size()) {
            log.warn("Found {} items but requested {}", items.size(), itemIds.size());
        }

        return processItems(items, prompt, modelConfigurationId, batchId);
    }

    /**
     * Generate summaries for items in a collection
     */
    public BatchSummaryResponse generateSummariesForCollection(
            Long collectionId,
            String prompt,
            Long modelConfigurationId
    ) {
        Long batchId = System.nanoTime();

        log.debug("Processing collection {} with batch ID {}", collectionId, batchId);

        // Get collection members using the relationship model
        var collectionRelationships = relationshipRepository.findCollectionMembers(collectionId);

        List<Long> itemIds = collectionRelationships.stream()
                .map(rel -> rel.getSourceItemId())  // Updated for new Relationship model
                .collect(Collectors.toList());

        List<Item> items = itemRepository.findAllById(itemIds);

        return processItems(items, prompt, modelConfigurationId, batchId);
    }

    /**
     * Core processing logic for any list of items
     */
    private BatchSummaryResponse processItems(
            List<Item> items,
            String prompt,
            Long modelConfigurationId,
            Long batchId
    ) {
        if (items.isEmpty()) {
            return new BatchSummaryResponse(0, 0, List.of(), "No items to process");
        }

        String systemPrompt = buildSystemPrompt(prompt);
        ModelConfiguration modelConfiguration = modelService.findConfigurationById(modelConfigurationId);

        log.debug("Processing {} items with batch ID {}", items.size(), batchId);

        // Process all items asynchronously
        List<CompletableFuture<AsyncItemProcessor.ProcessingResult>> futures = items.stream()
                .map(item -> asyncItemProcessor.processItemAsync(
                        item,
                        systemPrompt,
                        modelConfiguration,
                        batchId
                ))
                .collect(Collectors.toList());

        // Wait for all processing to complete
        List<AsyncItemProcessor.ProcessingResult> results = futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList());

        // Collect results
        List<Long> summaryIds = results.stream()
                .filter(AsyncItemProcessor.ProcessingResult::success)
                .map(AsyncItemProcessor.ProcessingResult::summaryId)
                .collect(Collectors.toList());

        int successCount = (int) results.stream().mapToInt(r -> r.success() ? 1 : 0).sum();
        int failureCount = results.size() - successCount;

        log.debug("Completed batch {}: {} successes, {} failures", batchId, successCount, failureCount);

        String message = String.format("Processed %d items: %d succeeded, %d failed",
                results.size(), successCount, failureCount);

        return new BatchSummaryResponse(successCount, failureCount, summaryIds, message);
    }

    /**
     * Build system prompt for item summarization
     */
    private String buildSystemPrompt(String userPrompt) {
        if (userPrompt != null && !userPrompt.trim().isEmpty()) {
            return userPrompt;
        }

        return """
            You are analyzing an item from a collection. The item details will be provided as JSON.
            Please provide a concise, informative summary of this item focusing on its key
            characteristics, significance, and notable features. Keep the summary to 2-3 sentences
            and make it suitable for comparative analysis with other items.

            For books: focus on genre, themes, and literary significance.
            For people: focus on their role, achievements, and historical importance.
            For other items: focus on their primary characteristics and relevance.
            """;
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/service/BaseAiApiService.java
package net.sampsoftware.genai.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@RequiredArgsConstructor

public class BaseAiApiService {

   @FunctionalInterface
    protected interface AICallFunction {
        String call() throws Exception;
    }

    protected String executeApiCall(AICallFunction apiCall) {
        try {
            return apiCall.call();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

}


-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/service/ChatService.java
package net.sampsoftware.genai.service;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class ChatService {

    private final AIService aiService;

    public String chat(String content) {
        // This is a simplified version that doesn't use model configurations
        // You could enhance this to use a default model configuration
        return aiService.generateResponse(content, null);
    }
}
-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/service/CytoscapeService.java
package net.sampsoftware.genai.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.controller.CytoscapeController.GraphStats;
import net.sampsoftware.genai.controller.CytoscapeController.ItemTypeCount;
import net.sampsoftware.genai.dto.CytoscapeDto;
import net.sampsoftware.genai.dto.SummaryRecords.DetailedSummaryRecord;
import net.sampsoftware.genai.model.Item;
import net.sampsoftware.genai.model.Relationship;
import net.sampsoftware.genai.repository.ItemRepository;
import net.sampsoftware.genai.repository.RelationshipRepository;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class CytoscapeService {

    private final ItemRepository itemRepository;
    private final SummaryService summaryService;
    private final RelationshipRepository relationshipRepository;

    /**
     * Generate a Cytoscape graph of items and their summaries
     */
    public CytoscapeDto getItemsSummariesGraph() {
        log.debug("Generating items-summaries graph");

        // Get all items
        List<Item> items = itemRepository.findAll();
        List<Long> itemIds = items.stream()
                .map(Item::getId)
                .toList();

        log.debug("Found {} items", items.size());

        // Get summaries for these items
        List<DetailedSummaryRecord> summaries = summaryService.findAllDetailedSummaryRecords()
                .stream()
                .filter(summary -> itemIds.contains(summary.itemId()))
                .collect(Collectors.toList());

        log.debug("Found {} summaries", summaries.size());

        return buildItemsSummariesGraph(items, summaries);
    }

    /**
     * Generate a graph focused on relationships between items
     */
    public CytoscapeDto getItemsRelationshipsGraph() {
        log.debug("Generating items-relationships graph");

        // Get all items and relationships
        List<Item> items = itemRepository.findAll();
        List<Relationship> relationships = relationshipRepository.findAll();

        log.debug("Found {} items and {} relationships", items.size(), relationships.size());

        return buildItemsRelationshipsGraph(items, relationships);
    }

    /**
     * Generate a graph for a specific collection
     */
    public CytoscapeDto getCollectionGraph(Long collectionId) {
        log.debug("Generating graph for collection {}", collectionId);

        // Get collection members
        List<Relationship> collectionMembers = relationshipRepository.findCollectionMembers(collectionId);
        List<Long> itemIds = collectionMembers.stream()
                .map(Relationship::getSourceItemId)
                .collect(Collectors.toList());

        // Get the items in this collection
        List<Item> items = itemRepository.findAllById(itemIds);

        // Get relationships between these items
        List<Relationship> relationships = relationshipRepository.findAll().stream()
                .filter(rel -> itemIds.contains(rel.getSourceItemId()) &&
                        itemIds.contains(rel.getTargetItemId()) &&
                        !rel.getRelationshipType().equals("collection")) // Exclude collection relationships
                .collect(Collectors.toList());

        log.debug("Found {} items and {} relationships in collection", items.size(), relationships.size());

        return buildItemsRelationshipsGraph(items, relationships);
    }

    /**
     * Generate graph filtered by item types
     */
    public CytoscapeDto getGraphByItemTypes(List<String> itemTypes, boolean includeRelationships) {
        log.debug("Generating graph for item types: {} (relationships: {})", itemTypes, includeRelationships);

        // Get items of specified types
        List<Item> items = itemRepository.findByItemTypeIn(itemTypes);
        List<Long> itemIds = items.stream().map(Item::getId).collect(Collectors.toList());

        if (includeRelationships) {
            // Get relationships between these items
            List<Relationship> relationships = relationshipRepository.findAll().stream()
                    .filter(rel -> itemIds.contains(rel.getSourceItemId()) &&
                            itemIds.contains(rel.getTargetItemId()))
                    .collect(Collectors.toList());

            return buildItemsRelationshipsGraph(items, relationships);
        } else {
            // Get summaries for these items
            List<DetailedSummaryRecord> summaries = summaryService.findAllDetailedSummaryRecords()
                    .stream()
                    .filter(summary -> itemIds.contains(summary.itemId()))
                    .collect(Collectors.toList());

            return buildItemsSummariesGraph(items, summaries);
        }
    }

    /**
     * Generate graph for items with summaries from a specific model
     */
    public CytoscapeDto getGraphByModel(Long modelId) {
        log.debug("Generating graph for model {}", modelId);

        // Get summaries from this model
        List<DetailedSummaryRecord> summaries = summaryService.findAllDetailedSummaryRecords()
                .stream()
                .filter(summary -> summary.modelId().equals(modelId))
                .collect(Collectors.toList());

        // Get the items that have these summaries
        List<Long> itemIds = summaries.stream()
                .map(DetailedSummaryRecord::itemId)
                .distinct()
                .collect(Collectors.toList());

        List<Item> items = itemRepository.findAllById(itemIds);

        return buildItemsSummariesGraph(items, summaries);
    }

    /**
     * Generate comprehensive graph with items, summaries, and relationships
     */
    public CytoscapeDto getComprehensiveGraph(int maxItems, List<String> itemTypes) {
        log.debug("Generating comprehensive graph (maxItems: {}, types: {})", maxItems, itemTypes);

        // Get items with limit
        List<Item> items;
        if (itemTypes != null && !itemTypes.isEmpty()) {
            items = itemRepository.findByItemTypeIn(itemTypes);
        } else {
            items = itemRepository.findAll(PageRequest.of(0, maxItems)).getContent();
        }

        // Limit items if needed
        if (items.size() > maxItems) {
            items = items.subList(0, maxItems);
        }

        List<Long> itemIds = items.stream().map(Item::getId).collect(Collectors.toList());

        // Get summaries
        List<DetailedSummaryRecord> summaries = summaryService.findAllDetailedSummaryRecords()
                .stream()
                .filter(summary -> itemIds.contains(summary.itemId()))
                .collect(Collectors.toList());

        // Get relationships
        List<Relationship> relationships = relationshipRepository.findAll().stream()
                .filter(rel -> itemIds.contains(rel.getSourceItemId()) &&
                        itemIds.contains(rel.getTargetItemId()))
                .collect(Collectors.toList());

        return buildComprehensiveGraph(items, summaries, relationships);
    }

    /**
     * Get available item types
     */
    public List<String> getAvailableItemTypes() {
        return itemRepository.findDistinctItemTypes();
    }

    /**
     * Get graph statistics
     */
    public GraphStats getGraphStats() {
        log.debug("Generating graph statistics");

        int totalItems = (int) itemRepository.count();
        int totalSummaries = summaryService.findAllDetailedSummaryRecords().size();
        int totalRelationships = (int) relationshipRepository.count();

        // Count collections (relationships with type 'collection_definition')
        int totalCollections = relationshipRepository.findByRelationshipType("collection_definition").size();

        // Get item type counts
        Map<String, Long> typeCounts = itemRepository.findAll().stream()
                .collect(Collectors.groupingBy(Item::getItemType, Collectors.counting()));

        List<ItemTypeCount> itemTypeCounts = typeCounts.entrySet().stream()
                .map(entry -> new ItemTypeCount(entry.getKey(), entry.getValue().intValue()))
                .collect(Collectors.toList());

        return new GraphStats(totalItems, totalSummaries, totalRelationships, totalCollections, itemTypeCounts);
    }

    // === PRIVATE HELPER METHODS ===

    /**
     * Build graph with items and summaries
     */
    private CytoscapeDto buildItemsSummariesGraph(List<Item> items, List<DetailedSummaryRecord> summaries) {
        List<CytoscapeDto.CytoscapeNode> nodes = new ArrayList<>();
        List<CytoscapeDto.CytoscapeEdge> edges = new ArrayList<>();

        // Add item nodes
        for (Item item : items) {
            nodes.add(CytoscapeDto.CytoscapeNode.builder()
                    .data(CytoscapeDto.NodeData.builder()
                            .id("item-" + item.getId())
                            .label(item.getName())
                            .type(item.getItemType())
                            .details(item)
                            .build())
                    .classes(item.getItemType())
                    .build());
        }

        // Add summary nodes and connect to items
        for (DetailedSummaryRecord summary : summaries) {
            String summaryId = "summary-" + summary.id();
            String itemId = "item-" + summary.itemId();

            // Add summary node
            nodes.add(CytoscapeDto.CytoscapeNode.builder()
                    .data(CytoscapeDto.NodeData.builder()
                            .id(summaryId)
                            .label(summary.modelName() + " Summary")
                            .type("summary")
                            .details(summary)
                            .build())
                    .classes("summary")
                    .build());

            // Connect summary to item
            edges.add(CytoscapeDto.CytoscapeEdge.builder()
                    .data(CytoscapeDto.EdgeData.builder()
                            .id("edge-" + itemId + "-" + summaryId)
                            .source(itemId)
                            .target(summaryId)
                            .label("summarizes")
                            .build())
                    .build());
        }

        // Group summaries by model type
        summaries.stream()
                .collect(Collectors.groupingBy(s -> s.modelName()))
                .forEach((modelName, modelSummaries) -> {
                    if (modelSummaries.size() > 1) {
                        // Create a model node
                        String modelId = "model-" + modelName.replaceAll("\\s+", "-").toLowerCase();

                        nodes.add(CytoscapeDto.CytoscapeNode.builder()
                                .data(CytoscapeDto.NodeData.builder()
                                        .id(modelId)
                                        .label(modelName)
                                        .type("model")
                                        .build())
                                .classes("model")
                                .build());

                        // Connect summaries to model
                        for (DetailedSummaryRecord summary : modelSummaries) {
                            String summaryId = "summary-" + summary.id();

                            edges.add(CytoscapeDto.CytoscapeEdge.builder()
                                    .data(CytoscapeDto.EdgeData.builder()
                                            .id("edge-" + modelId + "-" + summaryId)
                                            .source(summaryId)
                                            .target(modelId)
                                            .label("generated-by")
                                            .build())
                                    .build());
                        }
                    }
                });

        CytoscapeDto.Elements elements = new CytoscapeDto.Elements(nodes, edges);
        return CytoscapeDto.builder().elements(elements).build();
    }

    /**
     * Build graph with items and relationships
     */
    private CytoscapeDto buildItemsRelationshipsGraph(List<Item> items, List<Relationship> relationships) {
        List<CytoscapeDto.CytoscapeNode> nodes = new ArrayList<>();
        List<CytoscapeDto.CytoscapeEdge> edges = new ArrayList<>();

        // Add item nodes
        for (Item item : items) {
            nodes.add(CytoscapeDto.CytoscapeNode.builder()
                    .data(CytoscapeDto.NodeData.builder()
                            .id("item-" + item.getId())
                            .label(item.getName())
                            .type(item.getItemType())
                            .details(item)
                            .build())
                    .classes(item.getItemType())
                    .build());
        }

        // Add relationship edges
        for (Relationship relationship : relationships) {
            String sourceId = "item-" + relationship.getSourceItemId();
            String targetId = "item-" + relationship.getTargetItemId();
            String edgeId = "rel-" + relationship.getId();

            edges.add(CytoscapeDto.CytoscapeEdge.builder()
                    .data(CytoscapeDto.EdgeData.builder()
                            .id(edgeId)
                            .source(sourceId)
                            .target(targetId)
                            .label(relationship.getRelationshipType())
                            .build())
                    .build());
        }

        CytoscapeDto.Elements elements = new CytoscapeDto.Elements(nodes, edges);
        return CytoscapeDto.builder().elements(elements).build();
    }

    /**
     * Build comprehensive graph with items, summaries, and relationships
     */
    private CytoscapeDto buildComprehensiveGraph(List<Item> items, List<DetailedSummaryRecord> summaries, List<Relationship> relationships) {
        List<CytoscapeDto.CytoscapeNode> nodes = new ArrayList<>();
        List<CytoscapeDto.CytoscapeEdge> edges = new ArrayList<>();

        // Add item nodes
        for (Item item : items) {
            nodes.add(CytoscapeDto.CytoscapeNode.builder()
                    .data(CytoscapeDto.NodeData.builder()
                            .id("item-" + item.getId())
                            .label(item.getName())
                            .type(item.getItemType())
                            .details(item)
                            .build())
                    .classes(item.getItemType())
                    .build());
        }

        // Add summary nodes and edges
        for (DetailedSummaryRecord summary : summaries) {
            String summaryId = "summary-" + summary.id();
            String itemId = "item-" + summary.itemId();

            nodes.add(CytoscapeDto.CytoscapeNode.builder()
                    .data(CytoscapeDto.NodeData.builder()
                            .id(summaryId)
                            .label(summary.modelName() + " Summary")
                            .type("summary")
                            .details(summary)
                            .build())
                    .classes("summary")
                    .build());

            edges.add(CytoscapeDto.CytoscapeEdge.builder()
                    .data(CytoscapeDto.EdgeData.builder()
                            .id("edge-" + itemId + "-" + summaryId)
                            .source(itemId)
                            .target(summaryId)
                            .label("summarizes")
                            .build())
                    .build());
        }

        // Add relationship edges
        for (Relationship relationship : relationships) {
            String sourceId = "item-" + relationship.getSourceItemId();
            String targetId = "item-" + relationship.getTargetItemId();
            String edgeId = "rel-" + relationship.getId();

            edges.add(CytoscapeDto.CytoscapeEdge.builder()
                    .data(CytoscapeDto.EdgeData.builder()
                            .id(edgeId)
                            .source(sourceId)
                            .target(targetId)
                            .label(relationship.getRelationshipType())
                            .build())
                    .build());
        }

        CytoscapeDto.Elements elements = new CytoscapeDto.Elements(nodes, edges);
        return CytoscapeDto.builder().elements(elements).build();
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/service/ModelCallService.java
package net.sampsoftware.genai.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.model.ModelCall;
import net.sampsoftware.genai.repository.ModelCallRepository;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Service
@RequiredArgsConstructor
public class ModelCallService {

    private final ModelCallRepository modelCallRepository;

    @Async
    @Transactional
    public CompletableFuture<ModelCall> saveAsync(ModelCall modelCall) {
        try {
            ModelCall saved = modelCallRepository.save(modelCall);
            log.debug("Saved model call {} for provider {} config {}",
                    saved.getId(),
                    saved.getProvider(),
                    saved.getModelConfiguration() != null ? saved.getModelConfiguration().getId() : "none");
            return CompletableFuture.completedFuture(saved);
        } catch (Exception e) {
            log.error("Failed to save model call", e);
            return CompletableFuture.failedFuture(e);
        }
    }

    @Transactional(readOnly = true)
    public List<ModelCall> getCallsForConfiguration(Long configId) {
        return modelCallRepository.findByModelConfigurationIdOrderByCreatedAtDesc(configId);
    }

    @Transactional(readOnly = true)
    public List<ModelCall> getCallsForBatch(Long batchId) {
        return modelCallRepository.findByBatchIdOrderByCreatedAtDesc(batchId);
    }

    @Transactional(readOnly = true)
    public List<ModelCall> getCallsForProvider(String provider) {
        return modelCallRepository.findByProviderOrderByCreatedAtDesc(provider);
    }

    @Transactional(readOnly = true)
    public List<ModelCall> getFailedCalls() {
        return modelCallRepository.findBySuccessOrderByCreatedAtDesc(false);
    }

    @Transactional(readOnly = true)
    public List<ModelCall> getCallsInDateRange(Instant start, Instant end) {
        return modelCallRepository.findByDateRange(start, end);
    }

    @Transactional(readOnly = true)
    public Double getAverageResponseTime(Long configId) {
        return modelCallRepository.getAverageDurationByModelConfig(configId);
    }

    @Transactional(readOnly = true)
    public Double getAverageResponseTimeByProvider(String provider) {
        return modelCallRepository.getAverageDurationByProvider(provider);
    }

    @Transactional(readOnly = true)
    public Long getSuccessCount(String provider) {
        return modelCallRepository.countByProviderAndSuccess(provider, true);
    }

    @Transactional(readOnly = true)
    public Long getFailureCount(String provider) {
        return modelCallRepository.countByProviderAndSuccess(provider, false);
    }

    @Transactional(readOnly = true)
    public double getSuccessRate(String provider) {
        Long successCount = getSuccessCount(provider);
        Long failureCount = getFailureCount(provider);
        Long totalCount = successCount + failureCount;

        return totalCount > 0 ? (double) successCount / totalCount : 0.0;
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/service/ModelParameterService.java
package net.sampsoftware.genai.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.dto.ModelParameterDto;
import net.sampsoftware.genai.model.Model;
import net.sampsoftware.genai.model.ModelParameter;
import net.sampsoftware.genai.repository.ModelParameterRepository;
import net.sampsoftware.genai.repository.ModelRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ModelParameterService {

    private final ModelRepository modelRepository;
    private final ModelParameterRepository modelParameterRepository;
    
    /**
     * Add parameter guidance for a specific model
     */
    @Transactional
    public void addParameterGuidance(Long modelId, String paramName, 
                                   String description, String dataType,
                                   String minValue, String maxValue, 
                                   String defaultValue, Integer displayOrder) {
        
        Optional<Model> modelOpt = modelRepository.findById(modelId);
        if (modelOpt.isEmpty()) {
            throw new IllegalArgumentException("Model not found: " + modelId);
        }
        
        ModelParameter parameter = ModelParameter.builder()
            .model(modelOpt.get())
            .paramName(paramName)
            .description(description)
            .dataType(dataType)
            .minValue(minValue)
            .maxValue(maxValue)
            .defaultValue(defaultValue)
            .displayOrder(displayOrder)
            .build();
            
        modelParameterRepository.save(parameter);
    }
    
    /**
     * Get all parameters for a model as DTOs
     */
    @Transactional(readOnly = true)
    public List<ModelParameterDto> getParametersForModel(Long modelId) {
        return modelParameterRepository.findByModelIdOrderByDisplayOrder(modelId)
            .stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }
    
    /**
     * Convert a ModelParameter entity to a DTO
     * Safely handles the lazy-loaded model property
     */
    private ModelParameterDto convertToDto(ModelParameter param) {
        return new ModelParameterDto(
            param.getId(),
            param.getModel().getId(),
            param.getParamName(),
            param.getDescription(),
            param.getDataType(),
            param.getMinValue(),
            param.getMaxValue(),
            param.getDefaultValue(),
            param.getDisplayOrder()
        );
    }
}
-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/service/ModelService.java
package net.sampsoftware.genai.service;

import lombok.RequiredArgsConstructor;
import net.sampsoftware.genai.model.ModelConfiguration;
import net.sampsoftware.genai.repository.ModelConfigurationRepository;

import java.util.Optional;

import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class ModelService {
    private final ModelConfigurationRepository modelConfigurationRepo;


    public ModelConfiguration findConfigurationById(Long modelConfigurationId) {
        Optional<ModelConfiguration> modelConfigOpt = modelConfigurationRepo.findByIdWithModel(modelConfigurationId);
        if (modelConfigOpt.isEmpty()) {
            throw new RuntimeException("Model configuration not found");
        }
        ModelConfiguration modelConfig = modelConfigOpt.get();
        return modelConfig;
    }

}
-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/service/OperationsService.java
package net.sampsoftware.genai.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.model.*;
import net.sampsoftware.genai.repository.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Service
@RequiredArgsConstructor
public class OperationsService {

    private final RelationshipRepository relationshipRepository;
    private final ItemRepository itemRepository;
    private final SummaryService summaryService;
    private final ModelService modelService;
    private final AIService aiService;

    public record SummarizeEachResult(
            int successCount,
            int failureCount,
            List<Long> summaryIds
    ) {}

    public record SummarizeGroupResult(
            Long summaryId,
            Long collectionId,
            int entityCount
    ) {}

    public record GenerateRelationshipsResult(
            int relationshipCount,
            List<Long> relationshipIds,
            List<Long> summaryIds,
            int entityPairsProcessed
    ) {}

    @Transactional
    public SummarizeEachResult summarizeEachInCollection(Long modelConfigurationId, Long collectionId) {
        log.debug("Summarizing each item in collection {}", collectionId);

        // Get collection items using the unified Item model
        var collectionItems = relationshipRepository.findCollectionMembers(collectionId);

        var modelConfiguration = modelService.findConfigurationById(modelConfigurationId);
        var batchId = System.nanoTime();
        var summaryIds = new ArrayList<Long>();

        String systemPrompt = """
            You are analyzing an item from a collection. Please provide a concise, informative summary
            of this item focusing on its key characteristics, significance, and notable features.
            Keep the summary to 2-3 sentences and make it suitable for comparative analysis with other items.
            """;

        var futures = new ArrayList<CompletableFuture<Boolean>>();

        for (var relationship : collectionItems) {
            // Each relationship points to an item in the collection
            Long itemId = relationship.getSourceItemId();

            try {
                var itemInfo = buildItemInfo(itemId);

                var future = CompletableFuture.supplyAsync(() -> {
                    try {
                        String summaryText = aiService.generateResponse(systemPrompt, itemInfo, modelConfiguration);

                        var summary = Summary.builder()
                                .modelConfiguration(modelConfiguration)
                                .itemId(itemId)
                                .content(summaryText)
                                .batchId(batchId)
                                .build();

                        var savedSummary = summaryService.save(summary);
                        synchronized (summaryIds) {
                            summaryIds.add(savedSummary.getId());
                        }
                        return true;
                    } catch (Exception e) {
                        log.error("Failed to create summary for item {}: {}", itemId, e.getMessage());
                        return false;
                    }
                });

                futures.add(future);
            } catch (Exception e) {
                log.error("Error processing item {}: {}", itemId, e.getMessage());
            }
        }

        // Wait for all futures to complete
        var results = futures.stream()
                .map(CompletableFuture::join)
                .toList();

        int successCount = (int) results.stream().mapToInt(success -> success ? 1 : 0).sum();
        int failureCount = results.size() - successCount;

        log.debug("Completed summarize each: {} success, {} failures", successCount, failureCount);
        return new SummarizeEachResult(successCount, failureCount, summaryIds);
    }

    @Transactional
    public SummarizeGroupResult summarizeCollection(Long modelConfigurationId, Long collectionId) {
        log.debug("Summarizing collection {}", collectionId);

        // Get collection definition and items
        var collectionDefinitions = relationshipRepository.findCollectionDefinition(collectionId);
        if (collectionDefinitions.isEmpty()) {
            throw new RuntimeException("Collection definition not found for collection " + collectionId);
        }
        var collectionDefinition = collectionDefinitions.getFirst();

        var collectionItems = relationshipRepository.findCollectionMembers(collectionId);

        var modelConfiguration = modelService.findConfigurationById(modelConfigurationId);

        // Build comprehensive collection context
        var collectionContext = buildCollectionContext(collectionDefinition, collectionItems);

        String systemPrompt = """
            You are analyzing a collection of items. Please provide a comprehensive summary of this collection,
            including its theme, the types of items it contains, common patterns or relationships you observe,
            and the overall significance or purpose of grouping these items together.
            Focus on synthesis and high-level insights rather than listing individual items.
            """;

        String summaryText = aiService.generateResponse(systemPrompt, collectionContext, modelConfiguration);

        var summary = Summary.builder()
                .modelConfiguration(modelConfiguration)
                .itemId(collectionId)  // Collection itself is an item
                .content(summaryText)
                .build();

        var savedSummary = summaryService.save(summary);

        // Create relationship between summary and collection
        var summaryRelationship = new Relationship();
        summaryRelationship.setName("Summary of Collection");
        summaryRelationship.setRelationshipType("summarizes");
        summaryRelationship.setSourceItemId(savedSummary.getId());  // Summary as source
        summaryRelationship.setTargetItemId(collectionId);          // Collection as target
        relationshipRepository.save(summaryRelationship);

        return new SummarizeGroupResult(savedSummary.getId(), collectionId, collectionItems.size());
    }

    @Transactional
    public GenerateRelationshipsResult generateRelationships(
            Long modelConfigurationId,
            Long collectionId,
            List<String> relationshipTypes
    ) {
        log.debug("Generating relationships for collection {} with types {}", collectionId, relationshipTypes);

        var collectionItems = relationshipRepository.findCollectionMembers(collectionId);

        var modelConfiguration = modelService.findConfigurationById(modelConfigurationId);
        var relationshipIds = new ArrayList<Long>();
        var summaryIds = new ArrayList<Long>();
        int pairsProcessed = 0;

        String systemPrompt = String.format("""
            You are analyzing the relationship between two items.
            Please assess if there is a meaningful relationship between them from these types: %s
            
            Respond with JSON in this format:
            {
              "hasRelationship": true/false,
              "relationshipType": "one of the provided types or null",
              "confidence": 0.0-1.0,
              "explanation": "brief explanation of the relationship or why none exists"
            }
            """, String.join(", ", relationshipTypes));

        // Generate relationships for all pairs of items
        for (int i = 0; i < collectionItems.size(); i++) {
            for (int j = i + 1; j < collectionItems.size(); j++) {
                var item1 = collectionItems.get(i);
                var item2 = collectionItems.get(j);

                try {
                    var item1Info = buildItemInfo(item1.getSourceItemId());
                    var item2Info = buildItemInfo(item2.getSourceItemId());

                    var prompt = String.format("""
                        Item 1: %s
                        Item 2: %s
                        
                        Analyze the relationship between these items.
                        """, item1Info, item2Info);

                    var response = aiService.generateResponse(systemPrompt, prompt, modelConfiguration);

                    // Parse the JSON response and create relationships if found
                    if (response.contains("\"hasRelationship\": true")) {
                        var relationship = new Relationship();
                        relationship.setName(String.format("AI-Generated relationship between items %d and %d",
                                item1.getSourceItemId(), item2.getSourceItemId()));
                        relationship.setRelationshipType(extractRelationshipType(response, relationshipTypes));
                        relationship.setSourceItemId(item1.getSourceItemId());
                        relationship.setTargetItemId(item2.getSourceItemId());

                        var savedRelationship = relationshipRepository.save(relationship);
                        relationshipIds.add(savedRelationship.getId());

                        // Create a summary of this relationship analysis
                        var relationshipSummary = Summary.builder()
                                .modelConfiguration(modelConfiguration)
                                .itemId(savedRelationship.getId())  // Relationship as an item
                                .content(response)
                                .build();

                        var savedSummary = summaryService.save(relationshipSummary);
                        summaryIds.add(savedSummary.getId());
                    }

                    pairsProcessed++;
                } catch (Exception e) {
                    log.error("Error processing relationship between items {} and {}: {}",
                            item1.getSourceItemId(), item2.getSourceItemId(), e.getMessage());
                }
            }
        }

        return new GenerateRelationshipsResult(
                relationshipIds.size(),
                relationshipIds,
                summaryIds,
                pairsProcessed
        );
    }

    // === HELPER METHODS ===

    /**
     * Build item information for AI processing
     */
    private String buildItemInfo(Long itemId) {
        try {
            var itemOpt = itemRepository.findById(itemId);
            if (itemOpt.isEmpty()) {
                return String.format("Item ID: %d (not found)", itemId);
            }

            var item = itemOpt.get();
            StringBuilder info = new StringBuilder();

            info.append(String.format("Item ID: %d\n", item.getId()));
            info.append(String.format("Name: %s\n", item.getName()));
            info.append(String.format("Type: %s\n", item.getItemType()));

            // Check if attributes exist and are not null/empty
            if (item.getAttributes() != null && !item.getAttributes().isNull() && !item.getAttributes().isEmpty()) {
                info.append("Attributes:\n");
                var attributes = item.getAttributes();
                attributes.fieldNames().forEachRemaining(field -> {
                    var value = attributes.get(field);
                    info.append(String.format("- %s: %s\n", field, value.asText()));
                });
            }

            return info.toString();
        } catch (Exception e) {
            log.warn("Error building item info for item {}: {}", itemId, e.getMessage());
            return String.format("Item ID: %d (error retrieving details)", itemId);
        }
    }

    /**
     * Build collection context for AI processing
     */
    private String buildCollectionContext(Relationship collectionDefinition, List<Relationship> items) {
        var context = new StringBuilder();
        context.append(String.format("Collection: %s\n", collectionDefinition.getName()));

        if (collectionDefinition.hasAttributes()) {
            var attrs = collectionDefinition.getAttributes();
            if (attrs.has("description")) {
                context.append(String.format("Description: %s\n", attrs.get("description").asText()));
            }
            if (attrs.has("curator")) {
                context.append(String.format("Curator: %s\n", attrs.get("curator").asText()));
            }
        }

        context.append(String.format("Items (%d):\n", items.size()));
        for (var item : items) {
            context.append(String.format("- Item ID: %d\n", item.getSourceItemId()));
        }

        return context.toString();
    }

    /**
     * Extract relationship type from AI response
     */
    private String extractRelationshipType(String aiResponse, List<String> validTypes) {
        // Simple extraction - in practice you'd want proper JSON parsing
        for (String type : validTypes) {
            if (aiResponse.contains(String.format("\"%s\"", type))) {
                return type;
            }
        }
        return validTypes.getFirst(); // fallback
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/service/RelationshipService.java
package net.sampsoftware.genai.service;

import lombok.RequiredArgsConstructor;
import net.sampsoftware.genai.model.Relationship;
import net.sampsoftware.genai.repository.RelationshipRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class RelationshipService {
    private final RelationshipRepository relationshipRepository;

    @Transactional
    public Relationship createRelationship(Relationship relationship) {
        return relationshipRepository.save(relationship);
    }

    public List<Relationship> getRelationshipsForItem(Long itemId) {
        return relationshipRepository.findByEntity("item", itemId);
    }

    @Transactional(readOnly = true)
    public List<Relationship> getRelationshipsByType(String relationshipType) {
        return relationshipRepository.findByRelationshipType(relationshipType);
    }

    @Transactional(readOnly = true)
    public List<Relationship> getAllRelationships() {
        return relationshipRepository.findAll();
    }

    @Transactional(readOnly = true)
    public List<Relationship> getOutgoingRelationships(String sourceType, Long sourceId) {
        return relationshipRepository.findBySourceTypeAndSourceId(sourceType, sourceId);
    }

    @Transactional(readOnly = true)
    public List<Relationship> getIncomingRelationships(String targetType, Long targetId) {
        return relationshipRepository.findByTargetTypeAndTargetId(targetType, targetId);
    }


}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/service/SummaryService.java
package net.sampsoftware.genai.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.sampsoftware.genai.controller.SummaryController.BatchSummaryCount;
import net.sampsoftware.genai.controller.SummaryController.ModelSummaryCount;
import net.sampsoftware.genai.controller.SummaryController.SummaryStats;
import net.sampsoftware.genai.dto.SummaryRecords.DetailedSummaryRecord;
import net.sampsoftware.genai.dto.SummaryRecords.SummaryRecord;
import net.sampsoftware.genai.exception.ResourceNotFoundException;
import net.sampsoftware.genai.model.Item;
import net.sampsoftware.genai.model.Summary;
import net.sampsoftware.genai.repository.ItemRepository;
import net.sampsoftware.genai.repository.SummaryRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Complete summary service using unified Item model
 * Clean, simple, and powerful
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class SummaryService {

    private final SummaryRepository summaryRepository;
    private final ItemRepository itemRepository;

    // === CORE CRUD OPERATIONS ===

    @Transactional
    public Summary save(Summary summary) {
        return summaryRepository.save(summary);
    }

    @Transactional
    public SummaryRecord create(Summary summary) {
        Summary saved = summaryRepository.save(summary);
        return toSimpleDto(saved);
    }

    @Transactional
    public SummaryRecord update(Summary summary) {
        Summary existing = summaryRepository.findById(summary.getId())
                .orElseThrow(() -> new ResourceNotFoundException("Summary not found with id " + summary.getId()));

        // Update Summary fields - clean and simple with Item model
        existing.setItemId(summary.getItemId());
        existing.setContent(summary.getContent());
        existing.setModelConfiguration(summary.getModelConfiguration());
        existing.setBatchId(summary.getBatchId());
        if (summary.getMetadata() != null) {
            existing.setMetadata(summary.getMetadata());
        }

        return toSimpleDto(summaryRepository.save(existing));
    }

    @Transactional
    public void delete(Long id) {
        if (!summaryRepository.existsById(id)) {
            throw new ResourceNotFoundException("Summary not found with id " + id);
        }
        summaryRepository.deleteById(id);
    }

    // === QUERY OPERATIONS ===

    @Transactional(readOnly = true)
    public List<DetailedSummaryRecord> findAllDetailedSummaryRecords() {
        return summaryRepository.findAllWithDetails().stream()
                .map(this::toDetailedDto)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<DetailedSummaryRecord> findByItemIds(List<Long> itemIds) {
        return summaryRepository.findByItemIdIn(itemIds).stream()
                .map(this::toDetailedDto)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<DetailedSummaryRecord> findByBatchId(Long batchId) {
        return summaryRepository.findByBatchIdOrderByCreatedAtDesc(batchId).stream()
                .map(this::toDetailedDto)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<DetailedSummaryRecord> findByModelConfigurationId(Long modelConfigId) {
        return summaryRepository.findByModelConfigurationIdOrderByCreatedAtDesc(modelConfigId).stream()
                .map(this::toDetailedDto)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<DetailedSummaryRecord> findRecentSummaries(int limit) {
        return summaryRepository.findTopByOrderByCreatedAtDesc(limit).stream()
                .map(this::toDetailedDto)
                .collect(Collectors.toList());
    }

    // === STATISTICS AND ANALYTICS ===

    @Transactional(readOnly = true)
    public SummaryStats getSummaryStats() {
        log.debug("Generating summary statistics");

        int totalSummaries = (int) summaryRepository.count();
        int totalItems = (int) summaryRepository.countDistinctItems();
        int totalBatches = (int) summaryRepository.countDistinctBatches();

        // Get model summary counts
        List<Object[]> modelCounts = summaryRepository.countSummariesByModel();
        List<ModelSummaryCount> modelSummaryCounts = modelCounts.stream()
                .map(row -> new ModelSummaryCount(
                        (Long) row[0],      // modelId
                        (String) row[1],    // modelName
                        ((Number) row[2]).intValue()  // count
                ))
                .collect(Collectors.toList());

        // Get recent batch counts
        List<Object[]> batchCounts = summaryRepository.getRecentBatchCounts(10);
        List<BatchSummaryCount> recentBatches = batchCounts.stream()
                .map(row -> new BatchSummaryCount(
                        (Long) row[0],      // batchId
                        ((Number) row[1]).intValue(),  // count
                        row[2].toString()   // createdAt
                ))
                .collect(Collectors.toList());

        return new SummaryStats(totalSummaries, totalItems, totalBatches, modelSummaryCounts, recentBatches);
    }

    @Transactional(readOnly = true)
    public Map<String, Integer> getSummaryCountsByItemType() {
        List<Object[]> results = summaryRepository.countSummariesByItemType();
        return results.stream()
                .collect(Collectors.toMap(
                        row -> (String) row[0],                    // itemType
                        row -> ((Number) row[1]).intValue()        // count
                ));
    }


    // === DTO CONVERSION ===

    private SummaryRecord toSimpleDto(Summary summary) {
        return new SummaryRecord(
                summary.getId(),
                summary.getItemId(),
                summary.getContent(),
                summary.getCreatedAt()
        );
    }

    private DetailedSummaryRecord toDetailedDto(Summary summary) {
        // Resolve item information efficiently
        String itemName = resolveItemName(summary);
        String itemDetails = resolveItemDetails(summary);

        return new DetailedSummaryRecord(
                summary.getId(),
                summary.getItemId(),
                itemName,
                itemDetails,
                summary.getContent(),
                summary.getModelConfiguration().getModel().getModelName(),
                summary.getModelConfiguration().getModel().getModelProvider(),
                summary.getModelConfiguration().getModel().getId(),
                summary.getModelConfiguration().getId(),
                summary.getModelConfiguration().getModelConfig(),
                summary.getModelConfiguration().getComment(),
                summary.getCreatedAt()
        );
    }

    // === ITEM RESOLUTION ===

    /**
     * Resolve item name using unified Item model
     */
    private String resolveItemName(Summary summary) {
        try {
            return itemRepository.findById(summary.getItemId())
                    .map(Item::getName)
                    .orElse(String.format("Item #%d", summary.getItemId()));
        } catch (Exception e) {
            log.debug("Could not resolve item name for item {}: {}",
                    summary.getItemId(), e.getMessage());
            return String.format("Item #%d", summary.getItemId());
        }
    }

    /**
     * Resolve item details from Item's attributes
     */
    private String resolveItemDetails(Summary summary) {
        try {
            return itemRepository.findById(summary.getItemId())
                    .map(this::extractItemDetails)
                    .orElse(null);
        } catch (Exception e) {
            log.debug("Could not resolve item details for item {}: {}",
                    summary.getItemId(), e.getMessage());
            return null;
        }
    }

    /**
     * Extract meaningful details from Item's attributes JSONB field
     */
    private String extractItemDetails(Item item) {
        var attributes = item.getAttributes();
        if (attributes == null || attributes.isNull()) return null;

        // Build details based on item type and available attributes
        switch (item.getItemType().toLowerCase()) {
            case "book":
                return buildBookDetails(attributes);
            case "person":
                return buildPersonDetails(attributes);
            case "collection":
                return buildCollectionDetails(attributes);
            default:
                return buildGenericDetails(attributes);
        }
    }

    /**
     * Build details string for book items
     */
    private String buildBookDetails(com.fasterxml.jackson.databind.JsonNode attributes) {
        StringBuilder details = new StringBuilder();

        if (attributes.has("author") || attributes.has("authorName")) {
            String author = attributes.has("author") ?
                    attributes.get("author").asText() :
                    attributes.get("authorName").asText();
            details.append("Author: ").append(author);
        }

        if (attributes.has("publishYear") || attributes.has("year")) {
            if (details.length() > 0) details.append(", ");
            String year = attributes.has("publishYear") ?
                    attributes.get("publishYear").asText() :
                    attributes.get("year").asText();
            details.append("Year: ").append(year);
        }

        if (attributes.has("genre")) {
            if (details.length() > 0) details.append(", ");
            details.append("Genre: ").append(attributes.get("genre").asText());
        }

        return details.length() > 0 ? details.toString() : null;
    }

    /**
     * Build details string for person items
     */
    private String buildPersonDetails(com.fasterxml.jackson.databind.JsonNode attributes) {
        StringBuilder details = new StringBuilder();

        if (attributes.has("occupation")) {
            details.append("Occupation: ").append(attributes.get("occupation").asText());
        }

        if (attributes.has("birthDate")) {
            if (details.length() > 0) details.append(", ");
            details.append("Born: ").append(attributes.get("birthDate").asText());
        }

        if (attributes.has("nationality")) {
            if (details.length() > 0) details.append(", ");
            details.append("Nationality: ").append(attributes.get("nationality").asText());
        }

        return details.length() > 0 ? details.toString() : null;
    }

    /**
     * Build details string for collection items
     */
    private String buildCollectionDetails(com.fasterxml.jackson.databind.JsonNode attributes) {
        StringBuilder details = new StringBuilder();

        if (attributes.has("description")) {
            details.append(attributes.get("description").asText());
        }

        if (attributes.has("curator")) {
            if (details.length() > 0) details.append(" | ");
            details.append("Curator: ").append(attributes.get("curator").asText());
        }

        if (attributes.has("itemCount")) {
            if (details.length() > 0) details.append(" | ");
            details.append("Items: ").append(attributes.get("itemCount").asText());
        }

        return details.length() > 0 ? details.toString() : null;
    }

    /**
     * Build generic details for unknown item types
     */
    private String buildGenericDetails(com.fasterxml.jackson.databind.JsonNode attributes) {
        // Look for common fields that might be meaningful
        if (attributes.has("description")) {
            return attributes.get("description").asText();
        }

        if (attributes.has("summary")) {
            return attributes.get("summary").asText();
        }

        // If nothing specific, return null rather than dumping all attributes
        return null;
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/util/JsonAttributeUtil.java
package net.sampsoftware.genai.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

/**
 * Utility class for working with JSONB attributes
 */
@Component
@RequiredArgsConstructor
public class JsonAttributeUtil {
    private final ObjectMapper objectMapper;

    /**
     * Add or update a field in a JsonNode
     */
    public JsonNode setField(JsonNode node, String field, Object value) {
        ObjectNode objectNode = node != null && node.isObject()
                ? (ObjectNode) node
                : objectMapper.createObjectNode();

        objectNode.set(field, objectMapper.valueToTree(value));
        return objectNode;
    }

    /**
     * Get a field from a JsonNode as a specific type
     */
    public <T> T getField(JsonNode node, String field, Class<T> type) {
        if (node == null || !node.has(field)) {
            return null;
        }

        try {
            return objectMapper.treeToValue(node.get(field), type);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Error converting JSON field", e);
        }
    }

    /**
     * Check if a JsonNode has a specific field
     */
    public boolean hasField(JsonNode node, String field) {
        return node != null && node.has(field);
    }

    /**
     * Remove a field from a JsonNode
     */
    public JsonNode removeField(JsonNode node, String field) {
        if (node == null || !node.isObject()) {
            return node;
        }

        ObjectNode objectNode = (ObjectNode) node;
        objectNode.remove(field);
        return objectNode;
    }

    /**
     * Convert a Java object to a JsonNode
     */
    public JsonNode toJsonNode(Object value) {
        return objectMapper.valueToTree(value);
    }

    /**
     * Convert a JsonNode to a Java object
     */
    public <T> T fromJsonNode(JsonNode node, Class<T> type) {
        try {
            return objectMapper.treeToValue(node, type);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Error converting from JSON", e);
        }
    }
}

-----------

>>> ./backend/src/main/java/net/sampsoftware/genai/web/ModelConfigurationRequest.java
package net.sampsoftware.genai.web;

import com.fasterxml.jackson.databind.JsonNode;

public record ModelConfigurationRequest(
        Long modelId,
        JsonNode modelConfig,
        String comment
) {}

-----------

>>> ./backend/src/test/java/net/sampsoftware/genai/controller/ModelConfigurationControllerTest.java
package net.sampsoftware.genai.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import net.sampsoftware.genai.model.Model;
import net.sampsoftware.genai.repository.ModelRepository;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

import com.jayway.jsonpath.JsonPath;

@SpringBootTest
@AutoConfigureMockMvc
public class ModelConfigurationControllerTest  {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private ModelRepository modelRepository;

    @Test
    void createAndFetchModelConfiguration() throws Exception {
        // Create and save the Model entity first
        Model model = modelRepository.save(new Model(null, "gpt-4", "openai", "https://api.openai.com/v1", "test model"));

        // Create config JSON
        ObjectNode config = objectMapper.createObjectNode();
        config.put("temperature", 0.7);

        // Build JSON body for ModelConfigurationDto
        ObjectNode body = objectMapper.createObjectNode();
        body.put("modelId", model.getId());
        body.put("comment", "some comment");
        body.set("modelConfig", config);

        // Create ModelConfiguration
        String response = mockMvc.perform(post("/api/model-configurations")
                .contentType(MediaType.APPLICATION_JSON)
                .content(body.toString()))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.id").isNumber())
            .andReturn()
            .getResponse()
            .getContentAsString();

        Long configId = ((Integer)JsonPath.read(response, "$.id")).longValue();

        // Now GET by ID (this uses your fetch-joined method)
        mockMvc.perform(get("/api/model-configurations/{id}", configId))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.modelName").value("gpt-4"))
            .andExpect(jsonPath("$.modelProvider").value("openai"))
            .andExpect(jsonPath("$.modelConfig.temperature").value(0.7));
    }
}

-----------

>>> ./backend/src/test/java/net/sampsoftware/genai/controller/ModelControllerTest.java
package net.sampsoftware.genai.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import net.sampsoftware.genai.dto.ModelDto;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
class ModelControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void createAndFetchModel() throws Exception {
        ModelDto dto = new ModelDto();
        dto.setModelName("gpt-3.5");
        dto.setModelProvider("openai");
        dto.setModelApiUrl("https://api.openai.com");
        dto.setComment("test");

        String json = objectMapper.writeValueAsString(dto);

        String response = mockMvc.perform(post("/api/models")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").exists())
                .andReturn().getResponse().getContentAsString();

        ModelDto returned = objectMapper.readValue(response, ModelDto.class);
        assertThat(returned.getModelName()).isEqualTo("gpt-3.5");

        mockMvc.perform(get("/api/models/" + returned.getId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.modelProvider").value("openai"));
    }
}

-----------

>>> ./backend/src/test/java/net/sampsoftware/genai/repository/ModelConfigurationRepositoryTest.java
package net.sampsoftware.genai.repository;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import net.sampsoftware.genai.model.Model;
import net.sampsoftware.genai.model.ModelConfiguration;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
public class ModelConfigurationRepositoryTest {

    @Autowired
    private ModelConfigurationRepository configRepo;

    @Autowired
    private ModelRepository modelRepo;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void canSaveAndLoadModelConfiguration() {
        Model model = modelRepo.save(new Model(null, "gpt-4", "openai", "https://api.openai.com/v1", ""));

        ObjectNode configJson = objectMapper.createObjectNode();
        configJson.put("temperature", 0.7);

        ModelConfiguration config = ModelConfiguration.builder()
            .model(model)
            .modelConfig(configJson)
            .comment("Initial config")
            .createdAt(Instant.now())
            .build();

        ModelConfiguration saved = configRepo.save(config);
        assertThat(saved.getId()).isNotNull();
        ModelConfiguration loaded = configRepo.findById(saved.getId()).orElseThrow();
        assertThat(loaded.getModel().getId()).isEqualTo(model.getId());
        assertThat(loaded.getComment()).isEqualTo("Initial config");
        assertThat(loaded.getModelConfig().get("temperature").asDouble()).isEqualTo(0.7);

    }
}

-----------

>>> ./backend/src/test/java/net/sampsoftware/genai/repository/ModelRepositoryTest.java
package net.sampsoftware.genai.repository;

import net.sampsoftware.genai.model.Model;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
public class ModelRepositoryTest  {

    @Autowired
    private ModelRepository modelRepository;

    @Test
    void canSaveAndFindModel() {
        Model model = new Model(null, "gpt-4", "openai", "https://api.openai.com/v1", "test model");
        Model saved = modelRepository.save(model);

        assertThat(saved.getId()).isNotNull();
        assertThat(modelRepository.findById(saved.getId())).contains(saved);
    }
}
-----------
